module spral_ssids_akeep_gpu
   use spral_cuda, only : cudaMemcpy_h2d, cudaMalloc, cudaFree
   use spral_ssids_akeep, only : ssids_akeep_base
   use spral_ssids_datatypes, only : long, wp, SSIDS_ERROR_CUDA_UNKNOWN, &
                                     ssids_options
   use spral_ssids_inform, only : ssids_inform_base
   use spral_ssids_inform_gpu, only : ssids_inform_gpu
   use, intrinsic :: iso_c_binding
   implicit none

   private
   public :: ssids_akeep_gpu

   type, extends(ssids_akeep_base) :: ssids_akeep_gpu
      ! GPU pointers (copies of the CPU arrays of same name)
      type(C_PTR) :: gpu_nlist = C_NULL_PTR
      type(C_PTR) :: gpu_rlist = C_NULL_PTR
      type(C_PTR) :: gpu_rlist_direct = C_NULL_PTR
   contains
      procedure, pass(akeep) :: move_data
      procedure, pass(akeep) :: free => free_akeep_gpu
   end type ssids_akeep_gpu

contains

subroutine free_akeep_gpu(akeep, flag)
   class(ssids_akeep_gpu), intent(inout) :: akeep
   integer, intent(out) :: flag

   ! Call base class free
   call akeep%ssids_akeep_base%free(flag)

   ! Free GPU arrays if needed
   if(C_ASSOCIATED(akeep%gpu_nlist)) then
      flag = cudaFree(akeep%gpu_nlist)
      akeep%gpu_nlist = C_NULL_PTR
      if(flag.ne.0) return
   endif
   if(C_ASSOCIATED(akeep%gpu_rlist)) then
      flag = cudaFree(akeep%gpu_rlist)
      akeep%gpu_rlist = C_NULL_PTR
      if(flag.ne.0) return
   endif
   if(C_ASSOCIATED(akeep%gpu_rlist_direct)) then
      flag = cudaFree(akeep%gpu_rlist_direct)
      akeep%gpu_rlist_direct = C_NULL_PTR
      if(flag.ne.0) return
   endif
end subroutine free_akeep_gpu

subroutine move_data(akeep, options, inform)
   class(ssids_akeep_gpu), intent(inout) :: akeep
   type(ssids_options), intent(in) :: options
   class(ssids_inform_base), intent(inout) :: inform

   integer :: cuda_error

   ! First call base class version
   call akeep%ssids_akeep_base%move_data(options, inform)

   ! If we're not using the GPU, no need to copy data
   if(.not.options%use_gpu_factor .and. .not.options%use_gpu_solve) return

   ! Copy data to device
   cuda_error=0
   call copy_analyse_data_to_device(2*(akeep%nptr(akeep%nnodes+1)-1), &
      akeep%nlist, akeep%rptr(akeep%nnodes+1)-1, akeep%rlist, &
      akeep%rlist_direct, akeep%gpu_nlist, akeep%gpu_rlist, &
      akeep%gpu_rlist_direct, cuda_error)
   if(cuda_error .ne. 0) then
      select type(inform)
      type is (ssids_inform_gpu)
         inform%cuda_error = cuda_error
      end select
      inform%flag = SSIDS_ERROR_CUDA_UNKNOWN
      return
   endif
end subroutine move_data

!****************************************************************************
!
! Copy data generated by analyse phase to GPU
! (Specifically, nlist, rlist and rlist_direct)
!
subroutine copy_analyse_data_to_device(lnlist, nlist, lrlist, rlist, &
      rlist_direct, gpu_nlist, gpu_rlist, gpu_rlist_direct, cuda_error)
   integer, intent(in) :: lnlist
   integer(C_INT), dimension(lnlist), target, intent(in) :: nlist
   integer(long), intent(in) :: lrlist
   integer(C_INT), dimension(lrlist), target, intent(in) :: rlist
   integer(C_INT), dimension(lrlist), target, intent(in) :: rlist_direct
   type(C_PTR), intent(out) :: gpu_nlist
   type(C_PTR), intent(out) :: gpu_rlist
   type(C_PTR), intent(out) :: gpu_rlist_direct
   integer, intent(out) :: cuda_error ! Non-zero on error

   ! Copy nlist
   cuda_error = cudaMalloc(gpu_nlist, lnlist*C_SIZEOF(nlist(1)))
   if(cuda_error.ne.0) return
   cuda_error = cudaMemcpy_h2d(gpu_nlist, C_LOC(nlist), &
      lnlist*C_SIZEOF(nlist(1)))
   if(cuda_error.ne.0) return

   ! Copy rlist
   cuda_error = cudaMalloc(gpu_rlist, lrlist*C_SIZEOF(rlist(1)))
   if(cuda_error.ne.0) return
   cuda_error = cudaMemcpy_h2d(gpu_rlist, C_LOC(rlist), &
      lrlist*C_SIZEOF(rlist(1)))
   if(cuda_error.ne.0) return

   ! Copy rlist_direct
   cuda_error = cudaMalloc(gpu_rlist_direct, lrlist*C_SIZEOF(rlist_direct(1)))
   if(cuda_error.ne.0) return
   cuda_error = cudaMemcpy_h2d(gpu_rlist_direct, C_LOC(rlist_direct), &
      lrlist*C_SIZEOF(rlist_direct(1)))
   if(cuda_error.ne.0) return

end subroutine copy_analyse_data_to_device

end module spral_ssids_akeep_gpu
