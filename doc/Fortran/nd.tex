\packagename{ND}
\version{1.0.0}
\versiondate{?? July 2015}
\purpose{
Let $A$ be an $n \times n$ matrix with a symmetric sparsity pattern.
This package computes a {\bf nested dissection ordering} of $A$
that is suitable for use with a sparse direct solver. 

The algorithm starts by partitioning the rows/columns of $A$ into 3 sets such that 
reordering the rows/columns to respect their partitions yields a symmetric 
matrix of the form
\begin{equation}\label{eqn:partition}
\left(\begin{array}{c|c|c} A_1 & 0 & S_1^T \\\hline 0 & A_2 & S_2^T \\\hline S_1 & S_2 & S \end{array}   \right).
\end{equation}
The term {\it separator} is used to refer to the set of rows forming $S.$ 
If the dimension of submatrix $A_1$ ($A_2$) is smaller than some predefined value, the rows 
of $A_1$ ($A_2$) are ordered using an approximate minimum degree algorithm; 
otherwise,  $A_1$ ($A_2$) is partitioned to form 
another matrix with the above structure and the bisection algorithm  
applied in a recursive manner. A multilevel method or a level set-based method is used 
to compute the three sets that partition the matrix into the form (\ref{eqn:partition}). The 
algorithm allows for some dense or nearly dense rows and columns in $A$.
}

\title{Nested Dissection Ordering}
\author{
   Iain Duff (STFC Rutherford Appleton Laboratory) \\
   Jennifer Scott (STFC Rutherford Appleton Laboratory)\\
   Sue Thorne (STFC Rutherford Appleton Laboratory)
}
\pkglang{Fortran}
\spralmaketitle
\thispagestyle{firststyle}

\section*{Major version history}
\begin{description}
\item[2015-xx-xx Version 1.0.0] Initial release
\end{description}

%%%%%%%%%%%%%%%%%%%%%% installation %%%%%%%%%%%%%%%%%%%%%%

\section{Installation}
Please see the SPRAL install documentation.

%%%%%%%%%%%%%%%%%%%%%% how to use %%%%%%%%%%%%%%%%%%%%%%%%

\section{Usage overview}

\subsection{Calling sequences}

Access to the package requires a {\tt USE} statement \\ \\
\indent\hspace{8mm}{\tt use spral\_nd} \\

\medskip

\noindent
The following procedure is available to the user:
\begin{itemize}
\item {\tt nd\_order()} accepts the  pattern of the 
matrix $A$ in compressed sparse column format and generates an elimination ordering 
using a nested dissection strategy.


\end{itemize}


%%%%%%%%%%%%%%%%%%%%%% derived types %%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Derived types}

For each problem, the user must employ the derived types defined by the
package to declare scalars of the types
{\tt nd\_options} and {\tt nd\_inform}.
The following pseudo-code illustrates this.
\begin{verbatim}
      use spral_nd
      ...
      type (nd_options) :: options
      type (nd_inform) :: inform
      ...
\end{verbatim}
The components of {\tt nd\_options} and {\tt nd\_inform} are explained
in Sections~\ref{nd:type:options} and \ref{nd:type:inform}.

%\subsection{Achieving bit-compatibility}
%Care has been taken to ensure bit-compatibility is achieved using this solver.
%That is, consecutive runs with the same data on the same machine  produces exactly
%the same solution.

%\subsection{Optional arguments}

%We use square brackets {\tt [ ]} to indicate {\it optional} arguments.
%In each
%call, optional arguments follow the argument {\tt inform}.  Since we
%reserve the right to add additional optional arguments in future
%releases of the code, {\bf we strongly recommend that all optional
%arguments be called by keyword, not by position}.

\subsection{Integer, real and package types}

{\tt INTEGER} denotes default {\tt INTEGER}.% and
%{\tt INTEGER(long)} denotes {\tt INTEGER(kind=selected\_int\_kind(18))}.

\noindent
{\tt REAL} denotes double precision real.


\begin{figure}
   \caption{ \label{nd:format_eg}
      Data format example matrix
   }
   $$
      \left( \begin{array}{ccccc}
         \times & \times &     & \times &     \\
         \times &     & \times &     &     \\
             & \times & \times &     & \times \\
         \times &     &     & \times & \times \\
             &     & \times & \times & \times
      \end{array} \right)
   $$
\end{figure}

\subsection{Data formats: compressed sparse column (CSC) format} \label{nd:cscformat}
This standard data format consists of the following data:
\begin{verbatim}
   integer                   :: n      ! order of matrix
   integer, size(n+1)        :: ptr    ! column pointers
   integer, size(ptr(n+1)-1) :: row    ! row indices
\end{verbatim}
Non-zero matrix entries are  stored in
the array \texttt{row(:)}  such that \texttt{row(k)} holds
the row number of the \texttt{k}-th entry.
The \texttt{ptr(:)} array stores column pointers such that \texttt{ptr(i)} is
the position in \texttt{row(:)}  of
the first entry in the \texttt{i}-th column, and \texttt{ptr(n+1)} is one more
than the total number of entries.
Entries that are zero, including those on the diagonal, need not be specified. 
\texttt{nd\_order} does not require the user to 
input the values of the non-zero entries.
\texttt{nd\_order} allows the user to input just the lower triangular 
entries of $A$  or both the upper and lower triangular entries of $A.$

To illustrate the CSC format applied to the lower triangular part of a matrix, 
the following arrays describe the pattern of the matrix shown in
Figure~\ref{nd:format_eg}.
\begin{verbatim}
   n = 5
   ptr(1:6) = (/ 1,             4,   5,        7,        9,    10 /)
   row(1:9) = (/ 1,   2,   4,   3,   3,   5,   4,   5,   5 /)
\end{verbatim}

To illustrate the CSC format applied to the lower and upper triangular parts of 
a matrix, the following arrays describe the pattern of the matrix shown in
Figure~\ref{nd:format eg}.
\begin{verbatim}
   n = 5
   ptr(1:6) = (/ 1,          4,      6,          9,         12,       15 /)
   row(1:9) = (/ 1,  2,  4,  1,  3,  2,  3,  5,  1,  4,  5,  3, 4, 5 /)
\end{verbatim}


It is important to note
that {\bf no checks} are made on the user's data and any out-of-range entries 
or duplicates may cause {\tt nd\_order} to fail in an unpredictable way. 


%%%%%%%%%%%%%%%%%%%%%% argument lists %%%%%%%%%%%%%%%%%%%%%%%%

\section{Subroutines}

%%%%%%%%% analyse subroutine %%%%%%

\subsection{{\tt nd\_order()}}

{\bf To compute the nested dissection ordering,}
   \vspace*{0.3cm} \\
\texttt{\hspace*{0.2cm} call nd\_order(mtx,n,ptr,row,perm,options,inform)}
\vspace{0.3em}

\noindent
Matrix data should be supplied as described in Section~\ref{nd:dataformats}. 

\noindent
\begin{description}

\item[\texttt{mtx}] is an {\tt INTEGER} scalar with {\tt INTENT(IN)} that 
determines whether $A$ is input using only the lower triangular entries 
of $A$ or both the upper and lower triangular entries. The different options are 
\begin{description}
\item{\tt = 0 } Lower triangular entries provided.
\item{\tt = 1 } Upper and lower triangular entries provided.
\end{description}

\item[\texttt{n}, \texttt{ptr(:)} and \texttt{row(:)}] are \intentin\ variables. 
If {\tt mtx=0}, they must hold the \textbf{lower triangular part} of 
$A$ in CSC format;  if {\tt mtx=1}, they 
must hold the \textbf{lower and upper triangular parts} of $A$ in CSC format. 
See Section~\ref{nd:dataformats} for further details.

%\item[\texttt{n}] is an {\tt INTEGER} scalar with {\tt INTENT(IN)}.  On entry it
%must hold the order $n$ of $A$.
%{\bf  Restriction:} {\tt n $\ge$ \tt 1}.

%\item[\texttt{ptr(:)}] is an {\tt INTEGER(long)} array of rank one with {\tt INTENT(IN)}
%and size {\tt n+1}. \texttt{n}, \texttt{ptr(:)} and \texttt{row(:)} are used 
%to hold matrix data in CSC format (see Section~\ref{nd:dataformats}).

%\item[\texttt{row(:)}] is an {\tt INTEGER} array of rank one with {\tt INTENT(IN)}
%and size  {\tt ptr(n+1)-1}. On a call to {\tt nd\_lower}, it must be 
%set by the user so that {\tt row(1:ptr(n+1)-1)} holds the row indices of the 
%entries in the {\bf lower triangular part} of $A$; on a call to 
%{\tt mc70\_order\_full}, it must be set by the user so that 
%{\tt row(1:ptr(n+1)-1)} holds the row indices of the entries in 
%the {\bf lower and upper triangular parts} of $A.$ \texttt{n}, \texttt{ptr(:)} 
%and \texttt{row(:)} are used to hold matrix data in CSC format (see 
%Section~\ref{nd:dataformats}).

\item[\texttt{perm(:)}] is an {\tt INTEGER} array with {\tt INTENT(OUT)} and size
{\tt n}.  On exit, {\tt perm(:)} holds the nested dissection elimination ordering. 
The position of variable {\tt i} in the ordering is  {\tt perm(i)},
{\tt i=1,2,\ldots,n}.


\item[\texttt{options}] is an \intentin\ scalar of type {\tt nd\_options}.
Its components specify the algorithmic options used by the subroutine, as
explained in Section~\ref{nd:type:options}.

\item[\texttt{inform}] is an \intentout\ scalar of type
{\tt nd\_inform}. Its components provide information about the execution
of the subroutine, as explained in Section~\ref{nd:type:inform}.


\end{description}



%%%%%%%%%%% options type %%%%%%%%%%%

\section{Derived types}
\subsection{\texttt{nd\_options}}
\label{nd:type:options}

The derived data type {\tt nd\_options} is used to specify the options used
within \texttt{ND}. The components, that are automatically
given default values in the definition of the type, are: \\

%%%%%%%%%%%%
\subsubsection*{Printing options}

\begin{description}

\item[\texttt{print\_level}] is a scalar of type  {\tt INTEGER}
that is used to control the level of printing. The different levels are:
\begin{description}
\item{\tt $<$ 0 } No printing.
\item{\tt = 0 } Error  messages only.
\item{\tt = 1 } As 0, plus basic diagnostic printing.
\item{\tt $>$ 1 } As 1, plus some additional diagnostic printing.
\end{description}
The default is {\tt print\_level$=$\tt 0}.

\item[\texttt{unit\_diagnostics}] is a scalar  of type
{\tt INTEGER} that holds the
unit number for diagnostic printing. Printing is suppressed if
{\tt unit\_diagnostics$<0$}.
The default is {\tt unit\_diagnostics$=$6}.

\item[\texttt{unit\_error}] is a scalar of type  {\tt INTEGER} that holds the
unit number for error messages.
Printing of error messages
is suppressed if {\tt unit\_error$<$0}.
The default is {\tt unit\_error$=$6}.

\end{description}



%%%%%%%%%%%%
\subsubsection*{Other options (in alphabetical order)}

\begin{description}
\item[\texttt{amd\_call}] is an {\tt INTEGER} scalar that controls the use of 
the approximate minimum degree algorithm. If order of the matrix after the 
(optional) removal dense rows (see {\tt remove\_dense\_rows}) and (optional) 
compression using supervariables (see {\tt find\_supervariables}) is greater 
than {\tt amd\_call}, the matrix will be ordered using the nested dissection 
algorithm; otherwise, it will be ordered using an approximate minimum 
degree algorithm. Note, the approximate minimum degree algorithm will always be used if {\tt amd\_call=n}. The 
default is {\tt amd\_call=?????}.

\item[\texttt{amd\_switch1}] and {\tt amd\_switch2} are {\tt INTEGER} scalars 
that control when the nested dissection algorithm switches to using an approximated minimum 
degree algorithm. The switch is made when the order of the submatrix is less 
than or equal to {\tt amd\_switch1} or the current number of 
bisections performed is equal to {\tt amd\_switch2}.  The 
defaults are {\tt amd\_switch1=50} and {\tt amd\_switch2=20}.

\item[\texttt{balance}] is a {\tt REAL} scalar. The partitioning and refinement
methods aim to find partitions (\ref{eqn:partition}) such that the larger 
partition is at most {\tt balance} times the order of the smaller partition. 
Decreasing {\tt balance} will, in
general, result in an ordering that is more amenable to
parallel direct solvers; increasing {\tt balance} will, in general, reduce the
number of nonzeros in the Cholesky factorization of the reordered matrix. 
Values less than {\tt 1.0} are treated as {\tt 1.0}. The
default is {\tt balance=???}.

%\item[\texttt{cost\_function}] is an {\tt INTEGER} scalar. The quality of a candidate 
% partition is measured using a cost function, see {\tt balance}. Two possible 
% cost functions are provided. The different options are 
%\begin{description}
%\item{\tt $\le$ 1 } $\frac{n_s}{n_1 n_2};$
%\item{\tt $\ge$ 2 } $n_s \left( 1 + \frac{\left|n_1 - n_2\right|}{2\left(n_1 + n_2 + n_s\right)} \right);$
%\end{description}
% where $n_1$ and $n_2$ are the sum of the weights of the rows/columns forming 
% $A_1$ and $A_2,$ respectively, and $n_s$ is the sum of the weights of the 
% rows/columns forming $S.$ The default is {\tt cost\_function=1}.

\item[\texttt{coarse\_partition\_method}] is an {\tt INTEGER} scalar that 
controls partitioning of the coarsest matrix. The different options are:
\begin{description}
\item{\tt $=$ 1 } Partition using the half-level set method.
\item{\tt $=$ 2 } Partition using the level-set method.
\end{description}
See [1] for further details. The default is {\tt
coarse\_partition\_method=1}. 


\item[\texttt{find\_supervariables}] is a {\tt LOGICAL} scalar. If 
{\tt find\_supervariables=.true.}, the matrix $A$ (with any dense rows 
optionally removed, see {\tt remove\_dense\_rows}) is searched for 
supervariables and, if found, the matrix is compressed before applying the 
nested dissection algorithm; if {\tt find\_supervariables=.false.}, the matrix 
is not searched for supervariables. If supervariables exist and the matrix is 
compressed, the speed-up in the nested dissection algorithm normally 
compensates for the time spent searching for supervariables and compressing the 
matrix. The default is {\tt find\_supervariables=.true.}.


%\item[\texttt{max\_bisection\_depth}] is an {\tt INTEGER} scalar that holds the maximum number
%of nested dissection bisections. If the maximum number of bisections 
%is reached, the corresponding matrix in the nested dissection hierarchy 
%will be ordered using an approximate minimum degree algorithm. If 
%{\tt max\_bisection\_depth = 0}, the ordering of the input matrix is computed 
%using an approximate minimum degree algorithm.  Values less
%than {\tt 0} are treated as {\tt 0}.  The default is {\tt max\_bisection\_depth=20}.

\item[\texttt{max\_improve\_cycles}] is an {\tt INTEGER} scalar. Given a partition of the 
form (\ref{eqn:partition}), at most {\tt max\_improve\_cycles} cycles are 
performed to improve the quality of the partition. During each cycle, the 
separator is expanded to form a new partition and this new partition is 
subsequently refined. Increasing the value of {\tt max\_improve\_cycles} normally improves 
the quality of the nested dissection ordering but at the cost of increasing the 
time to form the ordering. The default is {\tt max\_improve\_cycles=?????}.

%\item[\texttt{ml\_bandwidth}] is a {\tt REAL} scalar and is only used if 
%{\tt ml$>$1}. Let $A$ be the matrix for which we wish to find a nested 
%dissection ordering, $\widetilde{A}$ be the matrix that results from 
%(optionally) removing any dense rows and compressing the matrix, and 
%{\tt ml$>$1}. Suppose that the Reverse Cuthill-McKee algorithm applied to 
%$\widetilde{A}$  yields a matrix with bandwidth $w.$ If 
%$w\ge 0.01\tilde{n}\times{\tt ml\_bandwidth},$ the multilevel partitioning 
%method is used within the nested dissection algorithm; otherwise, the 
%multilevel partitioning method is not used. The default is 
%{\tt ml\_bandwidth=0.01}.

\item[\texttt{matching}] is an {\tt INTEGER} scalar that determines the matching used during the multilevel partitioning scheme. The different options are: 
\begin{description}
\item{\tt $=$ 0 } Use common neighbours matching method.
\item{\tt $=$ 1 } Use heavy-edge matching method.
\end{description}
The default is {\tt matching=1}.



\item[\texttt{max\_reduction}] and {\tt min\_reduction} are {\tt REAL} scalars that hold the maximum and minimum reduction factors within the multilevel partitioning scheme. Suppose that the current coarse matrix has order $n_f$ and 
the subsequently coarsened matrix would have order $n_c,$ coarsening continues while $n_c<n_f\times{\tt max\_reduction}$ and 
$n_c>n_f\times{\tt min\_reduction}.$ {\tt max\_reduction} must be at least {\tt min\_reduction} and values greater than 
{\tt 1.0} are treated as {\tt 1.0}. {\tt min\_reduction} must be at least {\tt 0.5} and values less than 
{\tt 0.5} are treated as {\tt 0.5}. The defaults are {\tt max\_reduction=0.9} and {\tt min\_reduction=0.5}.











\item[\texttt{partition\_method}] is an {\tt INTEGER} scalar used to determine whether a multilevel 
partitioning scheme is used.  The different options are
\begin{description}
\item{\tt $=$ 0 } Multilevel partitioning scheme is {\bf not} used,
\item{\tt $=$ 1 } Multilevel partitioning scheme is  used,
\item{\tt $=$ 2 } Automatic choice of whether the multilevel partitioning scheme is used.
\end{description}
See Section~\ref{method} for further details. The default is {\tt partition\_method=2}.
%The multilevel partitioning scheme coarsens the matrix (reduces its order 
%whilst trying to maintain some of the structural properties) recursively. Once 
%the coarsened matrix is of order at most {\tt ml\_switch} or the maximum 
%number of multilevel recursions {\tt ml\_max\_levels} has been reached, the coarsened 
%matrix is partitioned (the partitioning method used is determined by 
%{\tt ml\_partition\_method}. This partition is projected (and refined) 
%up through the hierarchy of multilevel matrices. 
%The recursive multilevel partitioning method will 
%also stop coarsening if the next coarse matrix would be too small or too large 
%relative to the current coarse matrix, see {\tt ml\_max\_reduction} and 
%{\tt ml\_min\_reduction}. If the multilevel partitioning scheme is not 
%used, the matrix is partitioned using the method defined by 
%{\tt ml\_partition\_method}. See **PAPER** for further details 
%about multilevel partitioning. The default is {\tt partition\_method=2}. 


%\item[\texttt{refinement}] is an {\tt INTEGER} scalar that determines the method used to
%refine a partition. Given a matrix partition of the form (\ref{eqn:partition}),
%the partition is modified with the aim of reducing the size of $S$ and
%balancing the orders of $A_1$ and $A_2.$  The different options are
%\begin{description}
%\item{\tt $=$ 1 } Use trimming to reduce the order of $S$ and increase the orders of $A_1$ and $A_2.$ The new separator will be a subset of the old separator; 
%\item{\tt $=$ 2 } Use trimming to reduce the order of $S,$ increase the order of $A_i$ and reduce the order of $A_j,$ where $i,j\in\{1,2\}$ and $A_i$ is assumed to be smaller than $A_j.$ The new separator will be formed from a subset of the old separator and the rows that form $A_j;$ 
%\item{\tt $=$ 3 } Automatically choose between options {\tt 1} and {\tt 2} every time a partition is refined;
%\item{\tt $=$ 4 } Use the maximum flow algorithm to reduce the order of $S$ and increase the orders of $A_1$ and $A_2.$ The new separator will be a subset of the old separator; 
%\item{\tt $=$ 5 } Use the maximum flow algorithm to reduce the order of $S,$ increase the order of $A_i$ and reduce the order of $A_j,$ where $i,j\in\{1,2\}$ and $A_i$ is assumed to be smaller than $A_j.$ The new separator will be formed from a subset of the old separator and the rows that form $A_j;$
%\item{\tt $=$ 6 } Automatically choose between options {\tt 4} and {\tt 5} every time a partition is refined.
%\end{description}
%Values less than {\tt 1} are treated as {\tt 1} and values greater than {\tt 6} are treated as {\tt 6}.
% The default is {\tt refinement=6}. 

\item[\texttt{refinement\_band}] is an {\tt INTEGER} scalar used within the 
Fiduccia-Mattheyses refinement. The variables in the refined separator must be 
at most distance {\tt refinement\_band} from a variable that was in the input 
separator. See [1] for further details. In general, small 
values of {\tt refinement\_band} result in a faster method but the quality of 
the ordering may be compromised. The default is {\tt refinement\_band=4}.

\item[\texttt{remove\_dense\_rows}] is a {\tt LOGICAL} scalar. If {\tt remove\_dense\_rows = .true.}, 
then the matrix $A$ is searched for dense (or nearly dense) rows and columns, 
and the nested dissection algorithm is applied to the matrix that results when 
these rows and columns are removed. Dense rows/columns are placed at the end of 
the ordering. The default is {\tt remove\_dense\_rows=.true.}.



\item[\texttt{stop\_coarsening1}] is an {\tt INTEGER} scalar that holds the problem size in the multilevel hierarchy after which no further coarsening is performed.
The default is {\tt stop\_coarsening1=50}.

\item[\texttt{stop\_coarsening2}] is an {\tt INTEGER} scalar that holds the maximum number
of multilevel recursions.  
The default is {\tt stop\_coarsening2=20}.

\end{description}



%%%%%%%%%%% inform type %%%%%%%%%%%

\subsection{\texttt{nd\_inform}}
\label{nd:type:inform}
The derived data type {\tt nd\_inform}
is used to hold parameters that give information about the algorithm. The 
components of {\tt nd\_inform}
(in alphabetical order) are:

\begin{description}

\item[\texttt{flag}] is a scalar of type  {\tt INTEGER}
that gives the exit status of the algorithm (details in Section \ref{nd:errors}).

\item[\texttt{dense}] is a scalar of type {\tt INTEGER} that holds 
the number of rows/columns in the matrix $A$ that were determined to be dense. 
If {\tt options\%remove\_dense = .false.}, the input matrix is not checked for 
dense rows and {\tt dense = 0}.

\item[\texttt{nsuper}] is a scalar of type {\tt INTEGER} that holds the order 
of the matrix after dense rows have been (optionally) removed and 
the resulting matrix has been (optionally) compressed using supervariables. 

\item[\texttt{nzsuper}] is a scalar of type {\tt INTEGER} that holds the number of 
off-diagonal nonzero entries in the matrix after dense rows have been 
(optionally) removed and the resulting matrix has been (optionally) compressed 
using supervariables. 

\item[\texttt{stat}] is a scalar of type  {\tt INTEGER}
that holds the Fortran {\tt stat} parameter. 


\end{description}


%%%%%%%%%%%%%%%%%%%%%% Warning and error messages %%%%%%%%%%%%%%%%%%%%%%%%

\section{Return codes} \label{nd:errors}

A successful return is indicated by
{\tt inform\%flag} having the value zero.
A negative value is associated with an error message that by default will
be output on unit {\tt options\%unit\_error}.

Possible negative values are:

\begin{description}

\item{} {\tt -1} memory allocation failed.
\item{} {\tt -2} memory deallocation failed.
\item{} {\tt -3} {\tt n} $\le$ 0.
\end{description}


\section{Method} \label{method}

Given a matrix $A$ with a symmetric sparsity pattern of order $n,$ {\tt nd} preprocesses 
the matrix to (optionally) remove dense or almost dense rows/columns, returning 
$\overline{A}.$ The matrix $\overline{A}$ is then (optionally) searched for 
supervariables and, if found, it is compressed to give a symmetric matrix 
$\widetilde{A}$ with order $\tilde{n}.$ If $\tilde{n}$ is less than or equal to 
{\tt amd\_call}, an elimination ordering is computed using the 
approximate minimum degree (AMD) method; otherwise $\widetilde{A}$ is passed to the 
recursive nested dissection algorithm, \textbf{nested\_dissection($A,P$)}, below. Having formed a 
nested dissection ordering for $\widetilde{A},$ the 
ordering is mapped to give an ordering for $\overline{A}.$ The dense rows are 
appended to the end of the ordering. 

\noindent\hrulefill\\
\vspace{-1.0em}
\begin{algorithmic}
\STATE {\bf recursive subroutine nested\_dissection}($n,A,P$)
\STATE Input: symmetric matrix $A$ of order $n$
\STATE Output: permutation matrix $P$

\IF{$n<${\tt amd\_switch}}
\STATE compute an AMD elimination ordering for $A$ and return its equivalent 
permutation matrix $P$ 
\ELSE
\STATE partition $A$: compute $P,$ a permutation matrix, such that $P^T A P$ 
has the form (\ref{eqn:partition})
\STATE call {\bf nested\_dissection}($n_1,A_1,P_1$)
\STATE call {\bf nested\_dissection}($n_2,A_2,P_2$)
\STATE set $P \leftarrow PQ,$ where $$Q = \left( \begin{array}{ccc} P_1 & & \\ & P_2 & \\ & & I  \end{array} \right)$$
\ENDIF

\end{algorithmic}
\noindent\hrulefill\\

At each recursive level of the nested dissection procedure, the matrix is 
partitioned using either 
\begin{itemize}
\item the {\tt options\%coarse\_partition\_method} (see [1]), which is then refined to improve its 
quality, or 
\item a recursive multilevel procedure,  \textbf{multilevel\_partition($A$,$P$)} (see below), 
is performed, where \texttt{options\%matching} determines the strategy used to form 
the coarsening matrix.
\end{itemize}
The user may choose which partitioning method to use or {\tt ND} can analyse 
$\widetilde{A}$ and automatically choose how to partition the matrix, see 
\texttt{options\%partition\_method}.

\vspace{0.5cm}
\noindent\hrulefill\\
\vspace{-1.0em}
\begin{algorithmic}
\STATE {\bf recursive subroutine multilevel\_partition}($n,A,P$)
\STATE Input: symmetric matrix $A$ of order $n$
\STATE Output: permutation matrix $P$

\IF{$n<${\tt stop\_coarsening1}}
\STATE partition $A$ using the half-level set method and return its equivalent permutation matrix $P$ 
\ELSE
\STATE form coarsening matrix $R$ and set $A_c = R^T A R$
\STATE call {\bf multilevel\_partition}($A_c,P_c$)
\STATE set $P = RP_c$
\STATE refine $P$ to improve the partition of $A$
\ENDIF

\end{algorithmic}
\noindent\hrulefill


\section*{References}
[1] **Paper details **



%%%%%%%%%%%%%%%%%%%%%% EXAMPLE %%%%%%%%%%%%%%%%%%%%%%%%

\section{Example}

We illustrate the use of {\tt ND} on the following matrix: 

$$
	\left(\begin{array}{cccccccc}
   \times &  \times  &         &  \times  &  \times  & \times &          &           \\
   \times &  \times  &         &  \times  &          & \times &  \times  &           \\ 
          &          & \times  &          &  \times  & \times &          &           \\
   \times &  \times  &         &          &          &        &  \times  &           \\ 
   \times &          & \times  &          &  \times  & \times &          &   \times  \\ 
   \times &  \times  & \times  &          &  \times  &        &  \times  &   \times  \\ 
          &  \times  &         &  \times  &          & \times &          &           \\ 
          &          &         &          &  \times  & \times &          &   \times  \\ 
	\end{array}\right)
$$


\noindent{\bf Program}\smallskip

\def\baselinestretch{0.8}
{\small \begin{verbatim}
    PROGRAM example
      USE spral_nd
      IMPLICIT NONE

      ! Local variables
      INTEGER :: mtx, n, ne
      INTEGER, DIMENSION (:), ALLOCATABLE :: row, ptr, perm

      TYPE (mc70_options) :: options
      TYPE (mc70_inform) :: inform

      ! Set order n of the matrix and the number
      ! of non-zeros in its lower triangular part.
      n = 8 
      ne = 14

      ! Allocate arrays
      ALLOCATE (row(ne),ptr(n+1),perm(n),STAT=st)
      IF (st/=0) THEN
        WRITE (6,*) ' Allocation error'
        STOP
      END IF

      ! Matrix data
      ptr(1:n+1) = (/ 1 5 8 10 11 13 15 15 15 /)
      row(1:ne) = (/ 2 4 5 6 4 6 7 5 6 7 6 8 7 8 /)

      ! Call nested dissection and switch to approximate minimum degree when
      ! sub matrix has order less than or equal to 4
      options%amd_switch1 = 4
      options%amd_call = 3
      mtx = 0
      CALL nestd_order(mtx,n,ptr,row,perm,options,inform)

      ! Print out nested dissection ordering
      WRITE (6,'(a)') ' Permutation : '
      WRITE (6,'(8i8)') perm

      ! Deallocate all arrays
      DEALLOCATE (row,ptr,perm)

    END PROGRAM example
\end{verbatim}  }
\def\baselinestretch{1.0}
\medskip

\noindent
{ The input data is}

\def\baselinestretch{0.8}
{\small  \begin{verbatim}
8 14
1 5 8 10 11 13 15 15 15
2 4 5 6 4 6 7 5 6 7 6 8 7 8

\end{verbatim}  }
\medskip

\noindent
{This produces the following output}

\def\baselinestretch{0.8}
{\small { \begin{verbatim}
 Permutation :  
       7       1       5       2       6       8       3       4

\end{verbatim} } }
\medskip

\noindent
{\rm The permuted matrix is}

$$
	\left(\begin{array}{cccccccc}
    \times &  \times   &  \times  &          &          &        &   \times &   \times \\
    \times &           &  \times  &          &          &        &   \times &          \\ 
    \times &  \times   &          &          &          &        &          &   \times \\
           &           &          &   \times &          & \times &          &   \times \\ 
           &           &          &          &  \times  & \times &          &   \times \\ 
           &           &          &   \times &  \times  & \times &   \times &   \times \\ 
    \times &  \times   &          &          &          & \times &   \times &   \times \\ 
    \times &           &  \times  &   \times &  \times  & \times &   \times &          \\ 
	\end{array}\right)
$$

\begin{funders}
   \funder{epsrc}{Funded by EPSRC grant xxxxxxx}
\end{funders}
