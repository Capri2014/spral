\packagename{SCALING}
\version{1.0.0}
\versiondate{17 December 2014}
\purpose{
   This package generates various scalings (and matchings) of real sparse matrices.

   Given a \textbf{symmetric} matrix $A$, it finds a diagonal matrix $D$ such
   that the scaled matrix
   $$
      \hat{A} = DAD
   $$
   has specific numerical properties.

   Given a \textbf{unsymmetric} or \textbf{rectangular} matrix $A$, it finds
   diagonal matrices $D_r$ and $D_c$ such that the scaled matrix
   $$
      \hat{A} = D_r A D_c
   $$
   has specific numerical properties.

   The specific numerical properties delivered depends on the algorithm used:
   \begin{description}
      \item[Matching-based] algorithms scale $A$ such that the maximum
         (absolute) value in each row and column of $\hat{A}$ is exactly 1.0,
         where the entries of maximum value form a maximum cardinality matching.
         The \textbf{Hungarian algorithm} delivers an optimal matching slowly,
         whereas the \textbf{auction algorithm} delivers an approximate
         matching quickly.
      \item[Norm-equilibration] algorithms scale $A$ such that the infinity
         norm of each row and column of $\hat{A}$ is $1.0\pm \tau$ (for some
         user specified tolerance $\tau$).
   \end{description}
}

\title{Sparse Matrix Scalings}
\author{
   Jonathan Hogg (STFC Rutherford Appleton Laboratory) \\
}
\pkglang{Fortran}
\spralmaketitle
\thispagestyle{firststyle}

\section*{Major version history}
\begin{description}
\item[2014-12-17 Version 1.0.0] Initial public release
\end{description}

%%%%%%%%%%%%%%%%%%%%%% installation %%%%%%%%%%%%%%%%%%%%%%

\section{Installation}
Please see the SPRAL install documentation.

%%%%%%%%%%%%%%%%%%%%%% how to use %%%%%%%%%%%%%%%%%%%%%%%%

\section{Usage overview}

\subsection{Calling sequences}

Access to the package requires a {\tt USE} statement \\ \\
\indent\hspace{8mm}{\tt use spral\_scaling} \\

\medskip

\newpage
\noindent
The following procedures are available to the user:
\begin{itemize}
\item \texttt{auction\_scale\_sym()} and \texttt{auction\_scale\_unsym()} generate approximate matching-based scalings for symmetric and unsymmetric/rectangular matrices respectively using an auction algorithm.
\item \texttt{equilib\_scale\_sym()} and \texttt{equilib\_scale\_unsym()} generate norm-equilibration scalings for symmetric and unsymmetric/rectangular matrices respectively.
\item \texttt{hungarian\_scale\_sym()} and \texttt{hungarian\_scale\_unsym()} generate matching-based scalings for a symmetric and unsymmetric/rectangular matrices respectively using the Hungarian algorithm.
\end{itemize}

\subsection{Optional arguments}

We use square brackets {\tt [ ]} to indicate {\it optional} arguments.
In each
call, optional arguments appear last in argument list.  Since we
reserve the right to add additional optional arguments in future
releases of the code, {\bf we strongly recommend that all optional
arguments be called by keyword, not by position}.

\subsection{Integer, real and package types}

{\tt INTEGER} denotes default {\tt INTEGER} and
{\tt INTEGER(long)} denotes {\tt INTEGER(kind=selected\_int\_kind(18))}.

\noindent
{\tt REAL} denotes double precision real.
We also use the term {\bf package type} to mean the same.

\subsection{Data formats} \label{scaling:dataformats}

\begin{figure}
   \caption{ \label{scaling:format eg}
      Data format example matrix (symmetric)
   }
   $$
      \left( \begin{array}{ccccc}
         1.1 & 2.2 &     & 3.3 &     \\
         2.2 &     & 4.4 &     &     \\
             & 4.4 & 5.5 &     & 6.6 \\
         3.3 &     &     & 7.7 & 8.8 \\
             &     & 6.6 & 8.8 & 9.9
      \end{array} \right)
   $$
\end{figure}

\subsubsection{Compressed Sparse Column (CSC) Format}
This standard data format consists of the following data:
\begin{verbatim}
   integer                   :: m      ! number of rows (unsymmetric only)
   integer                   :: n      ! number of columns
   integer, size(n+1)        :: ptr    ! column pointers
   integer, size(ptr(n+1)-1) :: row    ! row indices
   real,    size(ptr(n+1)-1) :: val    ! numerical values
\end{verbatim}
Non-zero matrix entries are ordered by increasing column index and stored in
the arrays \texttt{row(:)} and \texttt{val(:)} such that \texttt{row(k)} holds
the row number and \texttt{val(k)} holds the value of the \texttt{k}-th entry.
The \texttt{ptr(:)} array stores column pointers such that \texttt{ptr(i)} is
the position in \texttt{row(:)} and \texttt{val(:)} of
the first entry in the \texttt{i}-th column, and \texttt{ptr(n+1)} is one more
than the total number of entries. There must be no duplicate or out of range
entries.
Entries that are zero, including those on the diagonal, need not be specified.

For \textbf{symmetric matrices}, only the lower triangular entries of $A$
should be supplied. For \textbf{unsymmetric matrices}, all entries in the matrix
should be supplied.

Note that these routines offer \textbf{no checking} of user data, and the
behaviour of these routines with misformatted data is undefined.

To illustrate the CSC format, the following arrays describe the symmetric
matrix shown in Figure~\ref{scaling:format eg}.
\begin{verbatim}
   n = 5
   ptr(1:6) = (/ 1,             4,   5,        7,        9,    10 /)
   row(1:9) = (/ 1,   2,   4,   3,   3,   5,   4,   5,   5 /)
   val(1:9) = (/ 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9 /)
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%% argument lists %%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%% Auction %%%%%%

\section{Auction Algorithm}

\subsection{\texttt{auction\_scale\_sym()}}

\textbf{\noindent
   To generate a scaling for a symmetric matrix using an auction algorithm such that the entry of maximum absolute value in each row and column is approximately 1.0,
   \vspace*{0.3cm} \\
   \texttt{ \hspace*{0.2cm}
      call auction\_scale\_sym(n, ptr, row, val, scaling, options, inform[, match])
   }
   \vspace{0.3cm}
}

\begin{description}

\item[\texttt{n}, \texttt{ptr(:)}, \texttt{row(:)}, \texttt{val(:)}] are \intentin\ variables that must hold the lower triangular part of $A$ in compressed sparse column format as described in Section~\ref{scaling:dataformats}.

\item[\texttt{scaling(n)}] is an \intentout\ array of package type. On exit,
\texttt{scaling(i)} holds $d_i$, the scaling corresponding to the
\texttt{i}-th row and column.

\item[\texttt{options}] is an \intentin\ scalar of type \texttt{auction\_options}. Its components specify the algorithmic options used by the subroutine, as explained in Section~\ref{scaling:type:auction_options}.

\item[\texttt{inform}] is an \intentout\ scalar of type \texttt{auction\_inform}. On exit, its components provide information about the execution of the subroutine, as explained in Section~\ref{scaling:type:auction_inform}.

\item[\texttt{match(n)}] is an optional \intentout\ array of type {\tt INTEGER}. If present, then on exit it specifies the matching of rows to
columns. Row \texttt{i} is matched to column \texttt{match(i)}, or is unmatched
if \texttt{match(i)}$=$\texttt{0}.

\end{description}

\subsection{\texttt{auction\_scale\_unsym()}}

\textbf{\noindent
   To generate a scaling for an unsymmetric or rectangular matrix using an auction algorithm such that the entry of maximum absolute value in each row and column is approximately 1.0,
   \vspace*{0.3cm} \\
   \texttt{ \hspace*{0.2cm}
      call auction\_scale\_unsym(m, n, ptr, row, val, rscaling, cscaling, options, inform[, match])
   }
   %\vspace{0.1cm}
}

\begin{description}

\item[\texttt{m}, \texttt{n}, \texttt{ptr(:)}, \texttt{row(:)}, \texttt{val(:)}] are \intentin\ variables that must hold $A$ in compressed sparse column format as described in Section~\ref{scaling:dataformats}.

\item[\texttt{rscaling(m)}] is an \intentout\ array of package type. On exit,
\texttt{rscaling(i)} holds $d^r_i$, the scaling corresponding to
the \texttt{i}-th row.

\item[\texttt{cscaling(n)}] is an \intentout\ array of package type. On exit,
\texttt{scaling(j)} holds $d^c_j$, the scaling corresponding to
the \texttt{j}-th column.

\item[\texttt{options}] is an \intentin\ scalar of type \texttt{auction\_options}. Its components specify the algorithmic options used by the subroutine, as explained in Section~\ref{scaling:type:auction_options}.

\item[\texttt{inform}] is an \intentout\ scalar of type \texttt{auction\_inform}. On exit, its components provide information about the execution of the subroutine, as explained in Section~\ref{scaling:type:auction_inform}.

\item[\texttt{match(m)}] is an optional \intentout\ array of type {\tt INTEGER}.
If present, then on exit it specifies the matching of rows to columns.
Row \texttt{i} is matched to column \texttt{match(i)}, or is unmatched
if \texttt{match(i)}$=$\texttt{0}.

\end{description}

\subsection{\texttt{type(auction\_options)}} \label{scaling:type:auction_options}

The derived data type \texttt{auction\_options} is used to specify the options
used by the routines \texttt{auction\_scale\_sym()} and \texttt{auction\_scale\_unsym()}. The components, that
are automatically given default values in the definition of the type, are:

\begin{description}

\item[\texttt{eps\_initial}] is a scalar of type default \texttt{REAL} that specifies the initial value of the minimum improvement parameter $\epsilon$ as described in Section~\ref{scaling:method:auction}.

\item[\texttt{max\_iterations}] is a scalar of type \texttt{INTEGER} that specifies the maximum number of iterations the algorithm may perform. The default is \texttt{max\_iterations}=\texttt{30000}.

\item[\texttt{max\_unchanged(3)}] is an array of type \texttt{INTEGER} that, together with \texttt{min\_proportion(:)} specifies termination conditions for the algorithm, as described in Section~\ref{scaling:method:auction}. The default is \texttt{max\_unchanged(:)} = \texttt{(/ 10, 100, 100 /)}.

\item[\texttt{min\_proportion(3)}] is an array of type default \texttt{REAL} that, together with \texttt{max\_unchanged(:)} specifies termination conditions for the algorithm, as described in Section~\ref{scaling:method:auction}. The default is \texttt{min\_proportion(:)} = \texttt{(/ 0.90, 0.0, 0.0 /)}.

\end{description}

\subsection{\texttt{type(auction\_inform)}} \label{scaling:type:auction_inform}

The derived data type \texttt{auction\_inform} is used to hold parameters that
give information about the progress of the routines
\texttt{auction\_scale\_sym()} and \texttt{auction\_scale\_unsym()}. The components are:

\begin{description}

\item[\texttt{flag}] gives the exit status of the algorithm (details in Section~\ref{scaling:errors:auction}).

\item[\texttt{iterations}] is a scalar of type \texttt{INTEGER} that holds the number of iterations performed.

\item[\texttt{matched}] is a scalar of type \texttt{integer} that holds the number of rows and columns that have been matched. As the algorithm may terminate before a full matching is obtained, this only provides a lower bound on the structural rank.

\item[\texttt{stat}] is a scalar of type \texttt{INTEGER}. In the event of an allocation error, it holds the Fortran \texttt{stat} parameter if it is available (and is set to \texttt{0} otherwise).

\item[\texttt{unmatchable}] is a scalar of type \texttt{integer} that holds the number of columns designated as unmatchable. A column is designated as unmatchable if there is no way to match it that improves the quality of the matching. It provides an approximate lower bound on the structural rank deficiency.

\end{description}

\subsection{Error Flags} \label{scaling:errors:auction}
A successful return from a routine is indicated by \texttt{inform\%flag} having the value zero. A negative value is associated with an error message.

Possible negative (error) values are:
\begin{description}
\item[\texttt{-1}] Allocation error. If available, the Fortran \texttt{stat} parameter is returned in \texttt{inform\%stat}.
\end{description}

\subsection{Algorithm description} \label{scaling:method:auction}

This algorithm finds a fast approximation to the matching and scaling produced
by the HSL package \texttt{MC64}. If an optimal matching is required, use the
Hungarian algorithm instead. The algorithm works by solving the following
maximum product optimization problem using an auction algorithm. The scaling
is derived from the dual variables associated with the solution.
\begin{eqnarray*}
   \max_{\sigma} & \prod_{i=1}^m\prod_{j=1}^n |a_{ij}|\sigma_{ij} & \\
   \mathrm{s.t.} & \sum_{i=1}^m\sigma_{ij} = 1, & \forall j=1,n \\
                 & \sum_{j=1}^n\sigma_{ij} = 1, & \forall i=1,m \\
                 & \sigma_{ij} \in \{0,1\}.
\end{eqnarray*}
The array $\sigma$ gives a matching of rows to columns.

By using the transformation
$$
   w_{ij} = \log c_j - \log |a_{ij}|,
$$
where $c_j = \max_i |a_{ij}|$, the maximum product problem in $a_{ij}$ is
replaced by a minimum sum problem in $w_{ij}$ where all entries are positive.
By standard optimization theory, there exist dual variables $u$ and $v$
corresponding to the constraints that satisfy the first order optimality
conditions
\begin{eqnarray*}
   w_{ij} - u_i - v_j = 0, && \mbox{if } \sigma_{ij }=1, \\
   w_{ij} - u_i - v_j \ge 0, && \mbox{if } \sigma_{ij }=0.
\end{eqnarray*}
To obtain a scaling we define scaling matrices $D_r$ and $D_c$ as
\begin{eqnarray*}
   & d^r_i = e^{u_i}, & \\
   & d^c_i = e^{v_i}. &
\end{eqnarray*}
If a symmetric scaling is required, we average these as
$$
   d_i = \sqrt{d^r_id^c_i}.
$$
By the first order optimality conditions, these scaling matrices guarantee that
\begin{eqnarray*}
   d^r_i|a_{ij}|d^c_j = 1, && \mbox{if } \sigma_{ij}=1, \\
   d^r_i|a_{ij}|d^c_j \le 1, && \mbox{if } \sigma_{ij}=0.
\end{eqnarray*}

To solve the minimum sum problem an auction algorithm is used. The 
algorithm is \textit{not} guaranteed to find an optimal matching. However it
can find an approximate matching very quickly. A matching is maintained along
with the row pricing vector $u$.
In each major iteration, we loop over each column in turn. If the
column $j$ is unmatched, we calculate the value $p_i = w_{ij} - u_i$ for each
entry and find the maximum across the column. If this maximum is positive, the
current matching can be improved by matching column $j$ with row $i$. This may
mean that the previous match of row $i$ now becomes unmatched. We update the
price of row $i$, that is $u_i$, to reflect this new benefit and continue to the
next column.

To prevent incremental shuffling, we insist that the value of
adding a new column is at least a threshold value $\epsilon$ above zero, where
$\epsilon$ is based on the last iteration in which row $i$ changed its match.
This is done by adding $\epsilon$ to the price $u_i$, where $\epsilon = \texttt{options\%eps\_initial} + \texttt{itr} / (n+1)$, where \texttt{itr} is the current iteration number.

The algorithm terminates if any of the following are satsified:
\begin{itemize}
   \item All entries are matched.
   \item The number of major iterations exceeds \texttt{options\%max\_iterations}.
   \item At least \texttt{options\%max\_unchanged(1)} iterations have passed without the cardinality of the matching increasing, and the proportion of matched columns is \texttt{options\%min\_proportion(1)}.
   \item At least \texttt{options\%max\_unchanged(2)} iterations have passed without the cardinality of the matching increasing, and the proportion of matched columns is \texttt{options\%min\_proportion(2)}.
   \item At least \texttt{options\%max\_unchanged(3)} iterations have passed without the cardinality of the matching increasing, and the proportion of matched columns is \texttt{options\%min\_proportion(3)}.
\end{itemize}

The different combinations given by \texttt{options\%max\_unchanged(1:3)}
and
\texttt{options\%min\_proportion(1:3)} allow a wide range of termination
heuristics to be specified by the user depending on their particular needs. Note
that the matching and scaling produced will always be approximate as
$\epsilon$ is non-zero.

\vspace{0.2cm}
\noindent
Further details are given in the following paper:
\vspace{-0.2cm}
\begin{itemize}
   \item[{[1]}] J.D. Hogg and J.A. Scott. (2014). On the efficient scaling of sparse symmetric matrices using an auction algorithm. RAL Technical Report RAL-P-2014-002.
\end{itemize}

\subsection{Example of auction\_scale\_sym()}
The following code shows an example usage of \texttt{auction\_scale\_sym()}.
\verbatiminput{examples/Fortran/scaling/auction_sym.f90}
The above code produces the following output.
\begin{verbatim}
Initial matrix:
Real symmetric indefinite matrix, dimension 5x5 with 8 entries.
1:   2.0000E+00   1.0000E+00                                       
2:   1.0000E+00   4.0000E+00   1.0000E+00                8.0000E+00
3:                1.0000E+00   3.0000E+00   2.0000E+00             
4:                             2.0000E+00                          
5:                8.0000E+00                             2.0000E+00
Matching:         1         5         4         3         2
Scaling:   7.07E-01  1.62E-01  2.78E-01  1.80E+00  7.72E-01
Scaled matrix:
Real symmetric indefinite matrix, dimension 5x5 with 8 entries.
1:   1.0000E+00   1.1443E-01                                       
2:   1.1443E-01   1.0476E-01   4.5008E-02                1.0000E+00
3:                4.5008E-02   2.3204E-01   1.0000E+00             
4:                             1.0000E+00                          
5:                1.0000E+00                             1.1932E+00
\end{verbatim}

%%%%%%%%% Equilibration %%%%%%

\section{Norm-equilibration algorithm}

\subsection{\texttt{equilib\_scale\_sym()}}

\textbf{\noindent
   To generate a scaling for a symmetric matrix using a norm equilibration algorithm such that the infinity norm of each row and column is equal to $1.0\pm\tau$,
   \vspace*{0.3cm} \\
   \texttt{ \hspace*{0.2cm}
      call equilib\_scale\_sym(n, ptr, row, val, scaling, options, inform)
   }
   \vspace{0.3cm}
}

\begin{description}

\item[\texttt{n}, \texttt{ptr(:)}, \texttt{row(:)}, \texttt{val(:)}] are \intentin\ variables that must hold the lower triangular part of $A$ in compressed sparse column format as described in Section~\ref{scaling:dataformats}.

\item[\texttt{scaling(n)}] is an \intentout\ array of package type. On exit,
\texttt{scaling(i)} holds $d_i$, the scaling corresponding to the
\texttt{i}-th row and column.

\item[\texttt{options}] is an \intentin\ scalar of type \texttt{equilib\_options}. Its components specify the algorithmic options used by the subroutine, as explained in Section~\ref{scaling:type:equilib_options}.

\item[\texttt{inform}] is an \intentout\ scalar of type \texttt{equilib\_inform}. On exit, its components provide information about the execution of the subroutine, as explained in Section~\ref{scaling:type:equilib_inform}.

\end{description}

\subsection{\texttt{equilib\_scale\_unsym()}}

\textbf{\noindent
   To generate a scaling for an unsymmetric or rectangular matrix using a norm equilibration algorithm such that the infinity norm of each row and column is equal to $1.0\pm\tau$,
   \vspace*{0.3cm} \\
   \texttt{ \hspace*{0.2cm}
      call equilib\_scale\_unsym(m, n, ptr, row, val, rscaling, cscaling, options, inform)
   }
   \vspace{0.3cm}
}

\begin{description}

\item[\texttt{m}, \texttt{n}, \texttt{ptr(:)}, \texttt{row(:)}, \texttt{val(:)}] are \intentin\ variables that must hold $A$ in compressed sparse column format as described in Section~\ref{scaling:dataformats}.

\item[\texttt{rscaling(m)}] is an \intentout\ array of package type. On exit,
\texttt{rscaling(i)} holds $d^r_i$, the scaling corresponding to the
\texttt{i}-th row.

\item[\texttt{cscaling(n)}] is an \intentout\ array of package type. On exit,
\texttt{cscaling(j)} holds $d^c_j$, the scaling corresponding to the
\texttt{j}-th column.

\item[\texttt{options}] is an \intentin\ scalar of type \texttt{equilib\_options}. Its components specify the algorithmic options used by the subroutine, as explained in Section~\ref{scaling:type:equilib_options}.

\item[\texttt{inform}] is an \intentout\ scalar of type \texttt{equilib\_inform}. On exit, its components provide information about the execution of the subroutine, as explained in Section~\ref{scaling:type:equilib_inform}.

\end{description}

\subsection{\texttt{type(equilib\_options)}} \label{scaling:type:equilib_options}

The derived data type \texttt{equilib\_options} is used to specify the options
used by the routine \texttt{equilib\_scale\_sym()}. The components, that are
automatically given default values in the definition of the type, are:

\begin{description}

\item[\texttt{max\_iterations}] is a scalar of type \texttt{INTEGER} that specifies the maximum number of iterations the algorithm may perform. The default is \texttt{max\_iterations}=\texttt{10}.

\item[\texttt{tol}] is a scalar of type default \texttt{REAL} that specifies the convergence tolerance $\tau$ for the algorithm (though often termination is based on \texttt{max\_iterations}). The default is \texttt{tol} = \texttt{1e-8}.

\end{description}

\subsection{\texttt{type(equilib\_inform)}} \label{scaling:type:equilib_inform}

The derived data type \texttt{equilib\_inform} is used to hold parameters that
give information about the progress of the routines
\texttt{equilib\_scale\_sym()} and \texttt{equilib\_scale\_unsym()}. The components are:

\begin{description}

\item[\texttt{flag}] gives the exit status of the algorithm (details in Section~\ref{scaling:errors:equilib}).

\item[\texttt{iterations}] is a scalar of type \texttt{INTEGER}. On exit, it
   holds the number of iterations performed.

\item[\texttt{stat}] is a scalar of type \texttt{INTEGER}. In the event of an allocation error, it holds the Fortran \texttt{stat} parameter if it is available (and is set to \texttt{0} otherwise).

\end{description}

\subsection{Error Flags} \label{scaling:errors:equilib}
A successful return from a routine is indicated by \texttt{inform\%flag} having the value zero. A negative value is associated with an error message.

Possible negative (error) values are:
\begin{description}
\item[\texttt{-1}] Allocation error. If available, the Fortran \texttt{stat} parameter is returned in \texttt{inform\%stat}.
\end{description}

\subsection{Algorithm description}

This algorithm is very similar to that used by the HSL routine \texttt{MC77}.
An iterative method
is used to scale the infinity norm of both rows and columns to 1 with an asymptotic linear rate of convergence of $\frac{1}{2}$, preserving symmetry if the matrix is symmetric.

\noindent
For unsymmetric matrices, the algorithm outline is as follows:
\begin{algorithmic}
   \setlength{\itemsep}{2pt}
   \STATE $D_r^{(0)} = I, D_c^{(0)}=I$
   \FOR{$k=1, \texttt{options\%max\_iterations}$}
      \setlength{\itemsep}{2pt}
      \STATE $A^{(k-1)} = D_r^{(k-1)} A D_c^{(k-1)}$
      \STATE $(D_r^{(k)})_{ii} = (D_r^{(k-1)})_{ii}\; /\; \sqrt{\max_j(A^{(k-1)})_{ij}}$
      \STATE $(D_c^{(k)})_{jj} = (D_c^{(k-1)})_{jj}\; /\; \sqrt{\max_i(A^{(k-1)})_{ij}}$
      \STATE\textbf{if}($|1-\|A^{(k-1)}\|_{\max}|\le\texttt{options\%tol}$) \textbf{exit}
   \ENDFOR
\end{algorithmic}
For symmetric matrices, $A^{(k-1)}$ is symmetric, so $D_r^{(k)} = D_c^{(k)}$, and
some operations can be skipped.

\vspace*{0.3cm}
\noindent
Further details are given in the following paper:
\vspace{-0.1cm}
\begin{itemize}
   \item[{[2]}] P. Knight, D. Ruiz and B. Ucar. (2012). A symmetry preserving algorithm for matrix scaling. INRIA Research Report 7552.
\end{itemize}

\subsection{Example of equilib\_scale\_sym()}
The following code shows an example usage of \texttt{equilib\_scale\_sym()}.
\verbatiminput{examples/Fortran/scaling/equilib_sym.f90}
The above code produces the following output.
\begin{verbatim}
Initial matrix:
Real symmetric indefinite matrix, dimension 5x5 with 8 entries.
1:   2.0000E+00   1.0000E+00                                       
2:   1.0000E+00   4.0000E+00   1.0000E+00                8.0000E+00
3:                1.0000E+00   3.0000E+00   2.0000E+00             
4:                             2.0000E+00                          
5:                8.0000E+00                             2.0000E+00
Scaling:   7.07E-01  3.54E-01  5.77E-01  8.66E-01  3.54E-01
Scaled matrix:
Real symmetric indefinite matrix, dimension 5x5 with 8 entries.
1:   1.0000E+00   2.5000E-01                                       
2:   2.5000E-01   5.0000E-01   2.0412E-01                1.0000E+00
3:                2.0412E-01   1.0000E+00   9.9960E-01             
4:                             9.9960E-01                          
5:                1.0000E+00                             2.5000E-01
\end{verbatim}

%%%%%%%%% Hungarian %%%%%%

\section{Hungarian algorithm}

\subsection{\texttt{hungarian\_scale\_sym()}}

\textbf{\noindent
   To generate a scaling for a symmetric matrix using the Hungarian algorithm such that the entry of maximum absolute value in each row and column is 1.0,
   \vspace*{0.3cm} \\
   \texttt{ \hspace*{0.2cm}
      call hungarian\_scale\_sym(n, ptr, row, val, scaling, options, inform[, match])
   }
   \vspace{0.3cm}
}

\begin{description}

\item[\texttt{n}, \texttt{ptr(:)}, \texttt{row(:)}, \texttt{val(:)}] are \intentin\ variables that must hold the lower triangular part of $A$ in compressed sparse column format as described in Section~\ref{scaling:dataformats}.

\item[\texttt{scaling(n)}] is an \intentout\ array of package type. On exit,
\texttt{scaling(i)} holds $d_i$, the scaling corresponding to the
\texttt{i}-th row and column.

\item[\texttt{options}] is an \intentin\ scalar of type \texttt{hungarian\_options}. Its components specify the algorithmic options used by the subroutine, as explained in Section~\ref{scaling:type:hungarian_options}.

\item[\texttt{inform}] is an \intentout\ scalar of type \texttt{hungarian\_inform}. On exit, its components provide information about the execution of the subroutine, as explained in Section~\ref{scaling:type:hungarian_inform}.

\item[\texttt{match(m)}] is an optional \intentout\ array of type {\tt INTEGER}.
If present, then on exit it specifies the matching of rows to
columns. Row \texttt{i} is matched to column \texttt{match(i)}, or is unmatched
if \texttt{match(i)}$=$\texttt{0}.

\end{description}

\subsection{\texttt{hungarian\_scale\_unsym()}}

\textbf{\noindent
   To generate a scaling for an unsymmetric or rectangular matrix using the Hungarian algorithm such that the entry of maximum absolute value in each row and column is 1.0,
   \vspace*{0.3cm} \\
   \texttt{ \hspace*{0.2cm}
      call hungarian\_scale\_unsym(m, n, ptr, row, val, rscaling, cscaling, options, inform[, match])
   }
   \vspace{0.3cm}
}

\begin{description}

\item[\texttt{m}, \texttt{n}, \texttt{ptr(:)}, \texttt{row(:)}, \texttt{val(:)}] are \intentin\ variables that must hold the lower triangular part of $A$ in compressed sparse column format as described in Section~\ref{scaling:dataformats}.

\item[\texttt{rscaling(m)}] is an \intentout\ array of package type. On exit,
\texttt{rscaling(i)} holds $d^r_i$, the scaling corresponding to the
\texttt{i}-th row.

\item[\texttt{rscaling(n)}] is an \intentout\ array of package type. On exit,
\texttt{rscaling(j)} holds $d^c_j$, the scaling corresponding to the
\texttt{j}-th column.

\item[\texttt{options}] is an \intentin\ scalar of type \texttt{hungarian\_options}. Its components specify the algorithmic options used by the subroutine, as explained in Section~\ref{scaling:type:hungarian_options}.

\item[\texttt{inform}] is an \intentout\ scalar of type \texttt{hungarian\_inform}. On exit, its components provide information about the execution of the subroutine, as explained in Section~\ref{scaling:type:hungarian_inform}.

\item[\texttt{match(m)}] is an optional \intentout\ array of type {\tt INTEGER}.
If present, then on exit it specifies the matching of rows to
columns. Row \texttt{i} is matched to column \texttt{match(i)}, or is unmatched
if \texttt{match(i)}$=$\texttt{0}.

\end{description}

\subsection{\texttt{type(hungarian\_options)}} \label{scaling:type:hungarian_options}

The derived data type \texttt{hungarian\_options} is used to specify the
options used by the routines \\\texttt{hungarian\_scale\_sym()} and \texttt{hungarian\_scale\_unsym()}. The components,
that are automatically given default values in the definition of the type, are:

\begin{description}

\item[\texttt{scale\_if\_singular}] is a scalar of type default \texttt{LOGICAL}
that specifies whether scaling should continue if the matrix $A$ is found to be
structurally singular. If \texttt{scale\_if\_singular}$=$\texttt{.true.},
and the $A$ is structurally singular, a partial scaling corresponding to a
maximum cardinality matching will be returned and a warning issued. Otherwise,
an identity scaling will be returned and an error issued.

\end{description}

\subsection{\texttt{type(hungarian\_inform)}} \label{scaling:type:hungarian_inform}

The derived data type \texttt{hungarian\_inform} is used to hold parameters
that give information about the progress of the routine
\texttt{hungarian\_scale\_sym()} and \texttt{hungarian\_scale\_unsym()}. The components are:

\begin{description}

\item[\texttt{flag}] gives the exit status of the algorithm (details in Section~\ref{scaling:errors:hungarian}).

\item[\texttt{matched}] is a scalar of type \texttt{INTEGER} that holds the number of rows and columns that have been matched (i.e.~the structural rank).

\item[\texttt{stat}] is a scalar of type \texttt{INTEGER}. In the event of an allocation error, it holds the Fortran \texttt{stat} parameter if it is available (and is set to \texttt{0} otherwise).
\end{description}

\subsection{Error Flags} \label{scaling:errors:hungarian}
A successful return from a routine is indicated by \texttt{inform\%flag} having the value zero. A negative value is associated with an error message and a positive value with a warning.

Possible negative (error) values are:
\begin{description}
\item[\texttt{-1}] Allocation error. If available, the Fortran \texttt{stat} parameter is returned in \texttt{inform\%stat}.
\item[\texttt{-2}] Matrix $A$ is structurally rank-deficient. This error is
   returned only if
   \texttt{options\%scale\_if\_singular}$=$\texttt{.false.}. The scaling vector
   is set to \texttt{1.0} and a matching of maximum cardinality returned
   in the optional argument \texttt{match(:)}, if present.
\end{description}

Possible positive (warning) values are:
\begin{description}
\item[\texttt{+1}] Matrix $A$ is structurally rank-deficient. This warning is
   returned only if
   \texttt{options\%scale\_if\_singular}$=$\texttt{.true.}.
\end{description}

\subsection{Algorithm description}

This algorithm is the same as used by the HSL package \texttt{MC64}. A scaling
is derived from dual variables found during the solution of the below
maximum product optimization problem using the Hungarian algorithm.
\begin{eqnarray*}
   \max_{\sigma} & \prod_{i=1}^m\prod_{j=1}^n |a_{ij}|\sigma_{ij} & \\
   \mathrm{s.t.} & \sum_{i=1}^m\sigma_{ij} = 1, & \forall j=1,n \\
                 & \sum_{j=1}^n\sigma_{ij} = 1, & \forall i=1,m \\
                 & \sigma_{ij} \in \{0,1\}.
\end{eqnarray*}
The array $\sigma$ gives a matching of rows to columns.

By using the transformation
$$
   w_{ij} = \log c_j - \log |a_{ij}|,
$$
where $c_j = \max_i |a_{ij}|$, the maximum product problem in $a_{ij}$ is
replaced by a minimum sum problem in $w_{ij}$ where all entries are positive.
By standard optimization theory, there exist dual variables $u$ and $v$
corresponding to the constraints that satisfy the first order optimality
conditions
\begin{eqnarray*}
   w_{ij} - u_i - v_j = 0, && \mbox{if } \sigma_{ij }=1, \\
   w_{ij} - u_i - v_j \ge 0, && \mbox{if } \sigma_{ij }=0.
\end{eqnarray*}
To obtain a scaling we define scaling matrices $D_r$ and $D_c$ as
\begin{eqnarray*}
   & d^r_i = e^{u_i}, & \\
   & d^c_i = e^{v_i}. &
\end{eqnarray*}
If a symmetric scaling is required, we average these as
$$
   d_i = \sqrt{d^r_id^c_i}.
$$
By the first order optimality conditions, these scaling matrices guarantee that
\begin{eqnarray*}
   d^r_i|a_{ij}|d^c_j = 1, && \mbox{if } \sigma_{ij}=1, \\
   d^r_i|a_{ij}|d^c_j \le 1, && \mbox{if } \sigma_{ij}=0.
\end{eqnarray*}

To solve the minimum sum problem, the Hungarian algorithm maintains an optimal
matching on a subset of
the rows and columns. It proceeds to grow this set by finding augmenting paths
from an unmatched row to an unmatched column. The algorithm is guaranteed to
find the optimal solution in a fixed number of steps, but can be very slow as
it may need to explore the full matrix a number of times equal to the dimension
of the matrix. To minimize the solution time, a warmstarting heuristic is used
to construct an initial optimal subset matching.

\noindent
Further details are given in the following paper:
\begin{itemize}
   \item[{[3]}] I.S. Duff and J. Koster. (1997). The design and use of algorithms for permuting large entries to the diagonal of sparse matrices. SIAM J. Matrix Anal. Applics. 20(4), pp 889--901.
\end{itemize}

\subsection{Example usage of hungarian\_scale\_unsym()}
The following code shows an example usage of \texttt{hungarian\_scale\_unsym()}.
\verbatiminput{examples/Fortran/scaling/hungarian_unsym.f90}
The above code produces the following output.
\begin{verbatim}
Initial matrix:
Real unsymmetric matrix, dimension 5x5 with 10 entries.
1:   2.0000E+00   5.0000E+00                                       
2:   1.0000E+00   4.0000E+00                             7.0000E+00
3:                1.0000E+00                2.0000E+00             
4:                             3.0000E+00                          
5:                8.0000E+00                             2.0000E+00
Matching:         1         5         4         3         2
Row Scaling:   5.22E-01  5.22E-01  5.22E-01  5.22E-01  5.22E-01
Col Scaling:   9.59E-01  2.40E-01  6.39E-01  9.59E-01  2.74E-01
Scaled matrix:
Real unsymmetric matrix, dimension 5x5 with 10 entries.
1:   1.0000E+00   6.2500E-01                                       
2:   5.0000E-01   5.0000E-01                             1.0000E+00
3:                1.2500E-01                1.0000E+00             
4:                             1.0000E+00                          
5:                1.0000E+00                             2.8571E-01
\end{verbatim}
