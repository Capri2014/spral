\packagename{SCALING}
\version{1.0.0}
\versiondate{3 December 2014}
\purpose{
   This package generates various scalings (and matchings) of sparse matrices.

   Given a real \textbf{symmetric} matrix $A$, it finds a digaonal matrix $D$ such
   that the scaled matrix
   $$
      \hat{A} = DAD
   $$
   has specific numerical properties.

   Given a real \textbf{unsymmetric} matrix $A$, it finds diagonal matrices $D_r$
   and $D_c$ such that the scaled matrix
   $$
      \hat{A} = D_r A D_c
   $$
   has specific numerical properties.

   The specific numerical properties delivered depends on the algorithm used:
   \begin{description}
      \item[Matching-based] algorithms scale $A$ such that the maximum
         (absolute) value in each row and column of $\hat{A}$ is exactly 1.0,
         where the entries of maximum value form a maximum cardinality matching.
         The \textbf{Hungarian algorithm} delivers an optimal answer slowly,
         whereas the \textbf{auction algorithm} delivers an approximate
         answer quickly.
      \item[Norm-equilibriation] algorithms scale $A$ such that the infinity
         norm of each row and column of $\hat{A}$ is exactly 1.0.
   \end{description}
}

\title{Sparse Matrix Scalings}
\author{
   Jonathan Hogg (STFC Rutherford Appleton Laboratory) \\
}
\pkglang{Fortran}
\spralmaketitle
\thispagestyle{firststyle}

\section*{Major version history}
\begin{description}
\item[2014-12-03 Version 1.0.0] Development version
\end{description}

%%%%%%%%%%%%%%%%%%%%%% installation %%%%%%%%%%%%%%%%%%%%%%

\section{Installation}
Please see the SPRAL install documentation.

%%%%%%%%%%%%%%%%%%%%%% how to use %%%%%%%%%%%%%%%%%%%%%%%%

\section{Usage overview}

\subsection{Calling sequences}

Access to the package requires a {\tt USE} statement \\ \\
\indent\hspace{8mm}{\tt use spral\_scaling} \\

\medskip

\noindent
The following procedures are available to the user:
\begin{itemize}
\item {\tt hungarian\_scale\_sym()} generates a matching-based scaling for a symmetric matrix using the Hungarian algorithm.
\item {\tt auction\_scale\_sym()} generates a matching-based scaling for a symmetric matrix using an auction algorithm.
\item {\tt equilb\_scale\_sym()} generates a norm equilibriation scaling for a symmetric matrix.
\end{itemize}

\subsection{Optional arguments}\label{Optional arguments}

We use square brackets {\tt [ ]} to indicate {\it optional} arguments.
In each
call, optional arguments appear last in argument list.  Since we
reserve the right to add additional optional arguments in future
releases of the code, {\bf we strongly recommend that all optional
arguments be called by keyword, not by position}.

\subsection{Integer, real and package types}\label{Integer kinds}

{\tt INTEGER} denotes default {\tt INTEGER} and
{\tt INTEGER(long)} denotes {\tt INTEGER(kind=selected\_int\_kind(18))}.

\noindent
{\tt REAL} denotes double precision real.
We also use the term {\bf package type} to mean the same.

\subsection{Data formats} \label{dataformats}

\begin{figure}
   \caption{ \label{format eg}
      Data format example matrix (symmetric)
   }
   $$
      \left( \begin{array}{ccccc}
         1.1 & 2.2 &     & 3.3 &     \\
         2.2 &     & 4.4 &     &     \\
             & 4.4 & 5.5 &     & 6.6 \\
         3.3 &     &     & 7.7 & 8.8 \\
             &     & 6.6 & 8.8 & 9.9
      \end{array} \right)
   $$
\end{figure}

\subsubsection{Compressed Sparse Column (CSC) Format} \label{cscformat}
This standard data format consists of the following data:
\begin{verbatim}
   integer                   :: n      ! size of matrix
   integer, size(n+1)        :: ptr    ! column pointers
   integer, size(ptr(n+1)-1) :: row    ! row indices
   real,    size(ptr(n+1)-1) :: val    ! numerical values
\end{verbatim}
Non-zero matrix entries are ordered by increasing column index and stored in
the arrays \texttt{row(:)} and \texttt{val(:)} such that \texttt{row(k)} holds
the row number and \texttt{val(k)} holds the value of the \texttt{k}-th entry.
The \texttt{ptr(:)} array stores column pointers such that \texttt{ptr(i)} is
the position in \texttt{row(:)} and \texttt{val(:)} of
the first entry in the \texttt{i}-th column, and \texttt{ptr(n+1)} is one more
than the total number of entries.
Entries that are zero, including those on the diagonal, need not be specified.

For symmetric matrices, only the lower triangular entries of $A$, should be
supplied, and there must be no duplicate entries. 

To illustrate the CSC format, the following arrays describe the matrix shown in
Figure~\ref{format eg}.
\begin{verbatim}
   n = 5
   ptr(1:6) = (/ 1,             4,   5,        7,        9,    10 /)
   row(1:9) = (/ 1,   2,   4,   3,   3,   5,   4,   5,   5 /)
   val(1:9) = (/ 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9 /)
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%% argument lists %%%%%%%%%%%%%%%%%%%%%%%%

\section{High-level Subroutines}

%%%%%%%%% Auction %%%%%%

\subsection{\texttt{auction\_scale\_sym()}}

\textbf{\noindent
   To generate a scaling for a real symmetric matrix using an auction algorithm such that the entry of maxmimum absolute value in each row and column is 1.0,
   \vspace*{0.1cm} \\
   \texttt{ \hspace*{0.2cm}
      call auction\_scale\_sym(n, ptr, row, val, scaling, options, inform[, match])
   }
   \vspace{0.3cm}
}

\begin{description}

\item[\texttt{n}, \texttt{ptr(:)}, \texttt{row(:)}, \texttt{val(:)}] are \intentin\ variables that must hold the lower triangular part of $A$ in compressed sparse column format as described in Section~\ref{cscformat}.

\item[\texttt{scaling}] is an \intentout\ array of package type. On exit,
\texttt{scaling(i)} will hold $D_{ii}$, the scaling corresponding to the
\texttt{i}-th row and column.

\item[\texttt{options}] is an \intentin\ scalar of type \texttt{auction\_options}. Its components specify the algorithmic options used by the subroutine, as explained in Section~\ref{type:auction_options}.

\item[\texttt{inform}] is an \intentout\ scalar of type \texttt{auction\_inform}. On exit, its components provide information about the execution of the subroutine, as explained in Section~\ref{type:auction_inform}.

\item[\texttt{match}] is an optional \intentout\ array of type {\tt INTEGER}.
If present, then on exit it specifies the matching of rows to columns.
Column \texttt{i} is matched to row \texttt{match(i)}.

\end{description}

%%%%%%%%% Equlibriation %%%%%%

\subsection{\texttt{equilib\_scale\_sym()}}

\textbf{\noindent
   To generate a scaling for a real symmetric matrix using a norm equilibriation algorithm such that the infinity norm of each row and column is equal,
   \vspace*{0.1cm} \\
   \texttt{ \hspace*{0.2cm}
      call equilib\_scale\_sym(n, ptr, row, val, scaling, st)
   }
   \vspace{0.3cm}
}

\begin{description}

\item[\texttt{n}, \texttt{ptr(:)}, \texttt{row(:)}, \texttt{val(:)}] are \intentin\ variables that must hold the lower triangular part of $A$ in compressed sparse column format as described in Section~\ref{cscformat}.

\item[\texttt{scaling}] is an \intentout\ array of package type. On exit,
\texttt{scaling(i)} will hold $D_{ii}$, the scaling corresponding to the
\texttt{i}-th row and column.

\item[\texttt{options}] is an \intentin\ scalar of type \texttt{equilib\_options}. Its components specify the algorithmic options used by the subroutine, as explained in Section~\ref{type:equilib_options}.

\item[\texttt{inform}] is an \intentout\ scalar of type \texttt{equilib\_inform}. On exit, its components provide information about the execution of the subroutine, as explained in Section~\ref{type:equilib_inform}.

\end{description}

%%%%%%%%% Hungarian %%%%%%

\subsection{\texttt{hungarian\_scale\_sym()}}

\textbf{\noindent
   To generate a scaling for a real symmetric matrix using the Hungarian algorithm such that the entry of maxmimum absolute value in each row and column is 1.0,
   \vspace*{0.1cm} \\
   \texttt{ \hspace*{0.2cm}
      call hungarian\_scale\_sym(n, ptr, row, val, scaling, options, inform[, match])
   }
   \vspace{0.3cm}
}

\begin{description}

\item[\texttt{n}, \texttt{ptr(:)}, \texttt{row(:)}, \texttt{val(:)}] are \intentin\ variables that must hold the lower triangular part of $A$ in compressed sparse column format as described in Section~\ref{cscformat}.

\item[\texttt{scaling}] is an \intentout\ array of package type. On exit,
\texttt{scaling(i)} will hold $D_{ii}$, the scaling corresponding to the
\texttt{i}-th row and column.

\item[\texttt{options}] is an \intentin\ scalar of type \texttt{hungarian\_options}. Its components specify the algorithmic options used by the subroutine, as explained in Section~\ref{type:hungarian_options}.

\item[\texttt{inform}] is an \intentout\ scalar of type \texttt{hungarian\_inform}. On exit, its components provide information about the execution of the subroutine, as explained in Section~\ref{type:hungarian_inform}.

\item[\texttt{match}] is an optional \intentout\ array of type {\tt INTEGER}.
If present, then on exit it specifies the matching of rows to columns.
Column \texttt{i} is matched to row \texttt{match(i)}.

\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Derived types}
\subsection{\texttt{auction\_options}} \label{type:auction_options}

The derived data type \texttt{auction\_options} is used to specify the options
used by the routine \texttt{auction\_scale\_sym()}. The components, that
are automatically given default values in the definition of the type, are:

\begin{description}

\item[\texttt{eps}] is a scalar of type default \texttt{REAL} that specifies the initial value of the minimum improvement parameter $\epsilon$ as described in Section~\ref{method:auction}.

\item[\texttt{max\_iterations}] is a scalar of type \texttt{INTEGER} that specifies the maximum number of iterations the algorithm may perform. The default is \texttt{max\_iterations}=\texttt{30000}.

\item[\texttt{max\_unchanged(3)}] is an array of type \texttt{INTEGER} that, together with \texttt{min\_proportion(:)} specifies termination conditions for the algorithm, as described in Section~\ref{method:auction}. The default is \texttt{max\_unchanged(:)} = \texttt{(/ 10, 100, 100 /)}.

\item[\texttt{min\_proportion(3)}] is an array of type default \texttt{REAL} that, together with \texttt{max\_unchanged(:)} specifies termination conditions for the algorithm, as described in Section~\ref{method:auction}. The default is \texttt{max\_unchanged(:)} = \texttt{(/ 0.90, 0.0, 0.0 /)}.

\end{description}

\subsection{\texttt{auction\_inform}} \label{type:auction_inform}

The derived data type \texttt{auction\_inform} is used to hold parameters that
give information about the progress of the routine
\texttt{auction\_scale\_sym()}. The components are:

\begin{description}

\item[\texttt{flag}] gives the exit status of the algorithm (details in Section~\ref{error flags}).

\item[\texttt{iterations}] is a scalar of type \texttt{INTEGER} that holds the number of iterations performed.

\item[\texttt{matched}] is a scalar of type \texttt{INTEGER} that holds the number of rows and columns that have been matched.

\item[\texttt{stat}] is a scalar of type \texttt{INTEGER}. In the event of an allocation or deallocation error, it holds the Fortran \texttt{stat} parameter if it is available (and is set to \texttt{0} otherwise).

\end{description}

\subsection{\texttt{equilib\_options}} \label{type:equilib_options}

The derived data type \texttt{equilib\_options} is used to specify the options
used by the routine \texttt{equilib\_scale\_sym()}. The components, that are
automatically given default values in the definition of the type, are:

\begin{description}

\item[\texttt{max\_iterations}] is a scalar of type \texttt{INTEGER} that specifies the maximum number of iterations the algorithm may perform. The default is \texttt{max\_iterations}=\texttt{10}.

\item[\texttt{tol}] is a scalar of type default \texttt{REAL} that specifies the convergence tolerance for the algorithm (though often termination is based on \texttt{max\_iterations}). The default is \texttt{tol} = \texttt{1e-8}.

\end{description}

\subsection{\texttt{equilib\_inform}} \label{type:equilib_inform}

The derived data type \texttt{equilib\_inform} is used to hold parameters that
give information about the progress of the routine
\texttt{equilib\_scale\_sym()}. The components are:

\begin{description}

\item[\texttt{flag}] gives the exit status of the algorithm (details in Section~\ref{error flags}).

\item[\texttt{stat}] is a scalar of type \texttt{INTEGER}. In the event of an allocation or deallocation error, it holds the Fortran \texttt{stat} parameter if it is available (and is set to \texttt{0} otherwise).
\end{description}

\subsection{\texttt{hungarian\_options}} \label{type:hungarian_options}

The derived data type \texttt{hungarian\_options} is used to specify the
options used by the routine \texttt{hungarian\_scale\_sym()}. The components,
that are automatically given default values in the definition of the type, are:

\begin{description}

\item[\texttt{scale\_if\_singular}] is a scalar of type default \texttt{LOGICAL}
that specifies whether scaling shuold continue if the matrix $A$ is found to be
structurally singular. If \texttt{scale\_if\_singular}$=$\texttt{.true.},
and the $A$ is structurally singular, a partial scaling corresponding to a
maximum cardinality matching will be returned and a warning issued. Otherwise
an identity scaling will be returned and an error issued.

\end{description}

\subsection{\texttt{hungarian\_inform}} \label{type:hungarian_inform}

The derived data type \texttt{hungarian\_inform} is used to hold parameters
that give information about the progress of the routine
\texttt{hungarian\_scale\_sym()}. The components are:

\begin{description}

\item[\texttt{flag}] gives the exit status of the algorithm (details in Section~\ref{error flags}).

\item[\texttt{stat}] is a scalar of type \texttt{INTEGER}. In the event of an allocation or deallocation error, it holds the Fortran \texttt{stat} parameter if it is available (and is set to \texttt{0} otherwise).
\end{description}

%%%%%%%%%%%%%% ERROR FLAGS %%%%%%%%%%%%%%%%%%%%%%

\section{Error Flags} \label{error flags}
A successful return from a routine is indicated by \texttt{inform\%flag} having the value zero. A negative value is associated with an error message and a positive value with a warning.

Possible negative (error) values are:
\begin{description}
\item[\texttt{-1}] Allocation error. If available, the Fortran \texttt{stat} parameter is returned in \texttt{inform\%stat}.
\item[\texttt{-2}] Matrix $A$ is structurally rank-deficient. This error is only
   returned by \texttt{hungarian\_scale\_sym()} and only if
   \texttt{options\%scale\_if\_singular}$=$\texttt{.false.}. The scaling vector
   will be set to \texttt{1.0} and a matching of maximum cardinality returned
   in the optional argument \texttt{match(:)}, if present.
\end{description}

Possible positive (warning) values are:
\begin{description}
\item[\texttt{+1}] Matrix $A$ is structurally rank-deficient. This warning is
   only returned by \texttt{hungarian\_scale\_sym()} and only if
   \texttt{options\%scale\_if\_singular}$=$\texttt{.true.}.
\end{description}

%%%%%%%%%%%%%% METHOD %%%%%%%%%%%%%%%%%%%%%%

\section{Method} \label{method}

\subsection{Matching-based algorithms}

Matching-based scaling algorithms first solve the maximum product optimization
problem
\begin{eqnarray*}
   \max_{\sigma} & \prod_{i=1}^m\prod_{j=1}^n |a_{ij}|\sigma_{ij} & \\
   \mathrm{s.t.} & \sum_{i=1}^m\sigma_{ij} = 1, & \forall j=1,n \\
                 & \sum_{j=1}^n\sigma_{ij} = 1, & \forall i=1,m \\
                 & \sigma_{ij} \in \{0,1\}.
\end{eqnarray*}
The array $\sigma$ gives a matching of rows to columns.

By using the transformation
$$
   w_{ij} = \log c_j - \log |a_{ij}|,
$$
where $c_j = \max_i |a_{ij}|$, the maximum product problem in $a_{ij}$ is
replaced by a minimum sum problem in $w_{ij}$ where all entries are positive.
By standard optimization theory we have dual variables $u$ and $v$ corresponding
to the constraints. These satisfy first order optimality conditions
\begin{eqnarray*}
   w_{ij} - u_i - v_j = 0, && \mbox{if } \sigma_{ij }=1, \\
   w_{ij} - u_i - v_j \ge 0, && \mbox{if } \sigma_{ij }=0.
\end{eqnarray*}
To obtain a scaling we define scaling matrices $D_r$ and $D_c$ as
\begin{eqnarray*}
   & d^r_i = e^{u_i}, & \\
   & d^c_i = e^{v_i}. &
\end{eqnarray*}
If a symmetric scaling is required, we average these as
$$
   d_i = \sqrt{d^r_id^c_i}.
$$
By the first order optimality conditions, these scaling matrices guarantee that
\begin{eqnarray*}
   d^r_i|a_{ij}|d^c_j = 1, && \mbox{if } \sigma_{ij}=1, \\
   d^r_i|a_{ij}|d^c_j \le 1, && \mbox{if } \sigma_{ij}=0.
\end{eqnarray*}

The Hungarian and Auction algorithms vary by the algorithm used to solve the
minimum sum problem.

\subsubsection{Hungarian algorithm}
This is the same algorithm as used by the HSL routine MC64.
The Hungarian algorithm works by maintaining an optimal matching on a subset of
the rows and columns. It proceeds to grow this set by finding augmenting paths
from an unmatched row to an unmatched column. The algorithm is guaranteed to
find the optimal solution in a fixed number of steps, but can be very slow as
it may need to explore the full matrix a number of times equal to the dimension
of the matrix. To minimize the solution time, a warmstarting heuristic is used
to construct an initial optimal subset matching.

\noindent
Further detail is given in the following paper:
\begin{itemize}
   \item[{[1]}] I.S. Duff and J. Koster. (1997). The design and use of algorithms for permuting large entries to the diagonal of sparse matrices. SIAM J. Matrix Anal. Applics. 20(4), pp 889--901.
\end{itemize}

\subsubsection{Auction algorithm} \label{method:auction}
The auction algorithm is not guaranteed to find an optimal matching, however it
can find an approximate matching very quickly. A matching is maintained along
with the row pricing vector $u$ (the other dual variable $v$ can be easily
calculated from knowledge of $u$ and the $\sigma$ after completion of the
algorithm). In each major iteration we loop over each column in turn. If the
column $j$ is unmatched we calculate the value $p_i = w_{ij} - u_i$ for each
entry and find the maximum across the column. If this maximum is positive, the
current matching can be improved by matching column $j$ with row $i$. This may
mean that the previous match of row $i$ now becomes unmatched. We update the
price of row $i$, that is $u_i$ to reflect this new benefit and continue to the
next column.

To prevent incremental shuffling, we insist that the value of
adding a new column is at least a threshold value $\epsilon$ above zero, where
$\epsilon$ is based on the last iteration in which row $i$ changed its match.
This is done by adding $\epsilon$ to the price $u_i$, where $\epsilon = \texttt{options\%eps} + \texttt{itr} / (n+1)$.

The algorithm terminates if:
\begin{itemize}
   \item All entries are matched
   \item The number of major iterations exceeds \texttt{options\%max\_iterations}.
   \item At least \texttt{options\%max\_unchanged(1)} iterations have passed without the cardinality of the matching increasing, and the proportion of matched columns is \texttt{options\%min\_proportion(1)}.
   \item At least \texttt{options\%max\_unchanged(2)} iterations have passed without the cardinality of the matching increasing, and the proportion of matched columns is \texttt{options\%min\_proportion(2)}.
   \item At least \texttt{options\%max\_unchanged(3)} iterations have passed without the cardinality of the matching increasing, and the proportion of matched columns is \texttt{options\%min\_proportion(3)}.
\end{itemize}

\noindent
Further detail is given in the following paper:
\begin{itemize}
   \item[{[2]}] J.D. Hogg and J.A. Scott. (2014). On the efficient scaling of sparse symmetric matrices using an auction algorithm. RAL Technical Report RAL-P-2014-002.
\end{itemize}

\subsection{Norm equilibriation algorithm}
This is similar to the algorithm used by the HSL routine MC77.
An iterative method
is used to scale the infinity norm of both rows and columns to 1 with an asymptotic linear rate of convergence of $\frac{1}{2}$, preserving symmetry if the matrix is symmetric.

\noindent
Further detail is given in the following paper:
\begin{itemize}
   \item[{[3]}] P. Knight, D. Ruiz and B. Ucar. (2012). A symmetry Preserving Algorithm for Matrix Scaling. INRIA Research Report 7552.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%% EXAMPLE %%%%%%%%%%%%%%%%%%%%%%%%

\section{Examples} \label{examples}

\subsection{auction\_scale\_sym()}
The following example code:
\verbatiminput{examples/Fortran/scaling/auction_sym.f90}
Produces the following output:
\begin{verbatim}
Initial matrix:
Real symmetric indefinite matrix, dimension 5x5 with 8 entries.
1:   2.0000E+00   1.0000E+00                                       
2:   1.0000E+00   4.0000E+00   1.0000E+00                8.0000E+00
3:                1.0000E+00   3.0000E+00   2.0000E+00             
4:                             2.0000E+00                          
5:                8.0000E+00                             2.0000E+00
Matching:         1         5         4         3         2
Scaling:   7.07E-01  1.62E-01  2.78E-01  1.80E+00  7.72E-01
Scaled matrix:
Real symmetric indefinite matrix, dimension 5x5 with 8 entries.
1:   1.0000E+00   1.1443E-01                                       
2:   1.1443E-01   1.0476E-01   4.5008E-02                1.0000E+00
3:                4.5008E-02   2.3204E-01   1.0000E+00             
4:                             1.0000E+00                          
5:                1.0000E+00                             1.1932E+00
\end{verbatim}


\subsection{equilib\_scale\_sym()}
The following example code:
\verbatiminput{examples/Fortran/scaling/equilib_sym.f90}
Produces the following output:
\begin{verbatim}
Initial matrix:
Real symmetric indefinite matrix, dimension 5x5 with 8 entries.
1:   2.0000E+00   1.0000E+00                                       
2:   1.0000E+00   4.0000E+00   1.0000E+00                8.0000E+00
3:                1.0000E+00   3.0000E+00   2.0000E+00             
4:                             2.0000E+00                          
5:                8.0000E+00                             2.0000E+00
Scaling:   7.07E-01  3.54E-01  5.77E-01  8.66E-01  3.54E-01
Scaled matrix:
Real symmetric indefinite matrix, dimension 5x5 with 8 entries.
1:   1.0000E+00   2.5000E-01                                       
2:   2.5000E-01   5.0000E-01   2.0412E-01                1.0000E+00
3:                2.0412E-01   1.0000E+00   9.9960E-01             
4:                             9.9960E-01                          
5:                1.0000E+00                             2.5000E-01
\end{verbatim}

\subsection{hungarian\_scale\_sym()}
The following example code:
\verbatiminput{examples/Fortran/scaling/hungarian_sym.f90}
Produces the following output:
\begin{verbatim}
Initial matrix:
Real symmetric indefinite matrix, dimension 5x5 with 8 entries.
1:   2.0000E+00   1.0000E+00                                       
2:   1.0000E+00   4.0000E+00   1.0000E+00                8.0000E+00
3:                1.0000E+00   3.0000E+00   2.0000E+00             
4:                             2.0000E+00                          
5:                8.0000E+00                             2.0000E+00
Matching:         1         5         4         3         2
Scaling:   7.07E-01  3.54E-01  5.77E-01  8.66E-01  3.54E-01
Scaled matrix:
Real symmetric indefinite matrix, dimension 5x5 with 8 entries.
1:   1.0000E+00   2.5000E-01                                       
2:   2.5000E-01   5.0000E-01   2.0412E-01                1.0000E+00
3:                2.0412E-01   1.0000E+00   1.0000E+00             
4:                             1.0000E+00                          
5:                1.0000E+00                             2.5000E-01
\end{verbatim}
