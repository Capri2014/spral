\packagename{SSMFE}
\version{1.0.0}
\versiondate{8 April 2015}

\newcommand{\solver}{ssmfe}
\newcommand{\Solver}{SSMFE}

\newcommand{\engine}{{\tt SPRAL\_\Solver\_CORE}}
\newcommand{\advanced}{{\tt SPRAL\_\Solver\_EXPERT}}
\newcommand{\fullpackagename}{{\tt SPRAL\_\Solver}}

\newcommand{\report}{Technical Report RAL-TR-2010-19}

\newcommand{\Double}{{\tt DOUBLE PRECISION}}
\newcommand{\Integer}{{\tt INTEGER}}
\newcommand{\Character}{{\tt CHARACTER}}
\newcommand{\Logical}{{\tt LOGICAL}}
\newcommand{\REALDP}{\texttt{REAL}}

\newcommand{\itt}[1]{{\item {\tt #1}}}
\newcommand{\Ref}[1]{{\rm (\ref{#1})}}


\purpose{
   This package computes extreme (leftmost and/or rightmost)
   eigenpairs $\{\lambda_i, x_i\}$ of the following eigenvalue problems:
%
   \begin{itemize}
      \item the standard eigenvalue problem
         \begin{eqnarray} \label{evp}
               A x = \lambda x,
         \end{eqnarray}
%
      \item the generalized eigenvalue problem
         \begin{eqnarray} \label{evp.g}
            A x = \lambda B x,
         \end{eqnarray}
      \item the buckling problem
         \begin{eqnarray} \label{evp.b}
            B x = \lambda A x,
         \end{eqnarray}
   \end{itemize}
   where  $A$ and $B$ are {\bf real symmetric} (or {\bf Hermitian}) matrices
   and $B$ is {\bf positive definite}.
}

\title{Sparse Symmetric Matrix-Free Eigensolver}
\author{
   Evgueni Ovtchinnikov (STFC Rutherford Appleton Laboratory)
}
\pkglang{Fortran}
\spralmaketitle
\thispagestyle{firststyle}

\section*{Major version history}
\begin{description}
\item[2014-11-20 Version 1.0.0] Initial release
\end{description}

%%%%%%%%%%%%%%%%%%%%%% installation %%%%%%%%%%%%%%%%%%%%%%

\section{Installation}
Please see the SPRAL install documentation. In particular note that:
\begin{itemize}
   \item A BLAS library is required.
   \item A LAPACK library is required.
\end{itemize}

\section{Usage overview}

\label{sec:summary}

The eigensolver subroutines
behind \fullpackagename\
implement a block iterative algorithm.
The block nature of this algorithm allows the user
to benefit from highly optimized linear algebra subroutines
and from the ubiquitous multicore architecture
of modern computers.
It also makes this algorithm more reliable
than Krylov-based algorithms employed e.g. by ARPACK
in the presence of clustered eigenvalues.
However, convergence of the iterations may be slow
if the density of the spectrum is high.

Thus, good performance 
(in terms of speed)
is contingent on the following two factors:
(i) the number of desired
eigenpairs must be substantial
(e.g. not less than the number of CPU cores),
and
(ii) the employment of a convergence acceleration technique.
The acceleration techniques that can be used 
are shift-and-invert and preconditioning.
The former requires
the direct solution of linear systems
with the matrix $A$ or its linear combination with $B$,
for which a sparse symmetric indefinite solver
(such as {\tt HSL\_MA97} or {\tt SPRAL\_SSIDS}) can be employed.
The latter applies to the case of positive definite $A$ and
requires a matrix or an operator\footnote{
That is, an algorithm producing a vector $v = T u$ for a given
vector $u$.
}
$T$, called {\em a preconditioner},
such that the vector
$v = T f$ is an approximation to the solution $u$
of the system $A u = f$
(see a simple example in Section~\ref{sec:ex.prec}).
This technique is more sophisticated
and is likely to be of interest only to experienced users.

Additional
options are offered by
the packages \advanced\ and \engine,
upon which \fullpackagename\ is built
and which are recommended for experienced users.
Further information on the algorithm used by
\fullpackagename\ can be found in the
specification document for \engine\
and in \report.

\subsection{Calling sequences}

\label{sec:call}

Access to the package requires a {\tt USE} statement \\ \\
\indent\hspace{8mm}{\tt use \fullpackagename} \\

\medskip

\noindent The following procedures are available to the user:
%
\begin{description}
\vspace{-0.1cm}
\item (a) {\tt \solver\_standard()} 
(for computing leftmost eigenpairs of \Ref{evp}, 
optionally using preconditioning)
\item (b) {\tt \solver\_standard\_shift()} 
(for computing eigenpairs of \Ref{evp} near a given shift %value
using the shift-and-invert technique)
\item (c) {\tt \solver\_generalized()} 
(for computing leftmost eigenpairs of 
\Ref{evp.g}, optionally using preconditioning)
\item (d) {\tt \solver\_generalized\_shift()} 
(for computing eigenpairs of 
\Ref{evp.g} near a given shift %value
using the shift-and-invert technique)
\item (e) {\tt \solver\_buckling()} 
(for computing eigenpairs of 
\Ref{evp.b} near a given shift %value
using the shift-and-invert technique)
\item (f) {\tt \solver\_terminate()} 
%
\end{description}

The solver procedures (a)--(e)
must be called repeatedly using
a reverse communication interface.
The terminating procedure (f)
should be called once after the
final call to 
a solver procedure
to deallocate all arrays 
that have been allocated by %any of 
the solver procedure.

\if 0
Several problems can be solved simultaneously,
i.e. the package does not require the solution of
one problem to be finished before the solution of
the next starts, as long as for each problem a separate set
of arguments for the above subroutines is used.
However, if two or more problems of the same type
need to be solved, it is reasonable to solve them one
after another  to reduce  memory requirements.
\fi

\subsection{Package types} 

We use the term {\bf package type} to mean
default double precision real for the double precision real version,
and default double precision complex
for the double precision complex version. 
%{\tt REAL} 
\REALDP\
denotes double precision real.

\subsection{Derived types}
\label{derived types}
For each problem, the user must employ the derived types defined by the
module to declare scalars of the types 
{\tt \solver\_rcid} (real version) or 
{\tt \solver\_rciz} (complex version), 
{\tt \solver\_keepd} (real version) or
{\tt \solver\_keepz} (complex version),
{\tt \solver\_options} and 
{\tt \solver\_inform}.
The following pseudocode illustrates this.
\begin{verbatim}
      use SPRAL_SSMFE    
      ...
      type (ssmfe_rcid   ) :: rcid
      type (ssmfe_keepd  ) :: keepd
      type (ssmfe_options) :: options
      type (ssmfe_inform ) :: inform
      ...
\end{verbatim}

The components of 
{\tt \solver\_options} and 
{\tt \solver\_inform} are explained
in Sections~\ref{sec:options} and \ref{sec:inform}. 
The components of {\tt \solver\_keepd} and {\tt \solver\_keepz} 
are used to pass 
private data between calls. 
The components of
{\tt \solver\_rcid} and 
{\tt \solver\_rciz} 
that are used by \fullpackagename\ 
for the reverse communication are
{\tt job},
{\tt nx},
{\tt ny}, all of default \Integer\ type,
and
{\tt x} and {\tt y},
which are 
two-dimensional arrays
of package type.

%%%%%%%%%%%%%%%%%%%%%% argument lists %%%%%%%%%%%%%%%%%%%%%%%%

\section{Argument lists}

\subsection{Solver procedures}

{\bf
To compute %several 
the leftmost eigenpairs of \Ref{evp},
optionally using preconditioning,
the following call must be made repeatedly:
}

\medskip
{\tt call
\solver\_standard( rci, left, mep, lambda, n, x, ldx, keep, options, inform )
}

\medskip
\noindent
{\bf
To compute the eigenvalues of \Ref{evp} %around 
in the vicinity of 
a given value {\tt sigma}
and the corresponding eigenvectors using the shift-and-invert technique,
the following call must be made repeatedly:
}

\medskip
{\tt call
\solver\_standard\_shift \&

\hspace{8mm} 
( rci, sigma, left, right, mep, lambda, n, x, ldx, keep, options, inform )
}

\medskip
\noindent
{\bf
To compute %several 
the leftmost eigenpairs of \Ref{evp.g},
optionally using preconditioning,
the following call must be made repeatedly:
}

\medskip
{\tt call
\solver\_generalized( rci, left, mep, lambda, n, x, ldx, keep, options, inform )
}

\medskip
\noindent
{\bf
To compute the eigenvalues of \Ref{evp.g} %around 
in the vicinity of 
a given value {\tt sigma}
and the corresponding eigenvectors using the shift-and-invert technique,
the following call must be made repeatedly:
}

\medskip
{\tt call
\solver\_generalized\_shift \&

\hspace{8mm} 
( rci, sigma, left, right, mep, lambda, n, x, ldx, keep, options, inform )
}

\medskip
\noindent
{\bf
To compute the eigenvalues of \Ref{evp.b} %around 
in the vicinity of 
a given value {\tt sigma}
and the corresponding eigenvectors %using the shift-and-invert technique
the following call must be made repeatedly:
}

\medskip
{\tt call
\solver\_buckling \&

\hspace{8mm} 
( rci, sigma, left, right, n, mep, lambda, x, ldx, keep, options, inform )
}

%\medskip
%\noindent
%{\bf Arguments common to all procedures.}

\begin{description}
%
\itt{rci} is is an \intentinout\ scalar  of type
{\tt \solver\_rcid} in the real version and
{\tt \solver\_rciz} in the complex version.
Before the first call, {\tt rci\%job} must be set to {\tt 0}.
No other values may be assigned to {\tt rci\%job} by the user.
After each call,
the value of {\tt rci\%job} must be inspected by the user's code
and the appropriate action taken (see below for details).
The following values of {\tt rci\%job}
are common to all solver procedures 
and require the same action: 
%
\begin{description}
%
\itt{-3}: fatal error return, the computation must be terminated;
%
\itt{-2}: 
non-fatal error return, the computation may be restarted,
see Section~\ref{sec:err} for the guidance;
%
\itt{-1}: the computation is complete and successful.
%
\itt{~1}: 
the user must multiply the {\tt n}$\times${\tt rci\%nx} matrix
{\tt rci\%x} by $A$ and place the result into {\tt rci\%y}.
%
\itt{~2}: 
({\tt\solver\_standard}\ and {\tt\solver\_generalized}\ only)
the user must
apply the preconditioner $T$ to the {\tt n}$\times${\tt rci\%nx} matrix
{\tt rci\%x} and place the result into {\tt rci\%y}.
%
\itt{~3}: 
({\tt\solver\_generalized}, {\tt\solver\_generalized\_shift}\
and {\tt\solver\_buckling}\ only)
the user must multiply the {\tt n}$\times${\tt rci\%nx} matrix
{\tt rci\%x} by $B$ and place the result into {\tt rci\%y}.
%
\itt{~9}:
({\tt\solver\_standard\_shift}, {\tt\solver\_generalized\_shift}\
and {\tt\solver\_buckling}\ only)
the solution of the shifted system
with the right-hand side {\tt n}$\times${\tt rci\%nx} matrix {\tt rci\%x}
must be placed into {\tt rci\%y}.
For problem \Ref{evp}, the shifted matrix is $A - \sigma I$,
where $I$ is $n\times n$ identity.
For problem \Ref{evp.g}, the shifted matrix is $A - \sigma B$.
For problem \Ref{evp.b}, the shifted matrix is $B - \sigma A$.
%
\end{description}
%
{\bf Restriction:} 
{\tt rci\%job = 0} is the only value that can be assigned by the user.
%
\itt{sigma} 
({\tt \solver\_standard\_shift}, {\tt \solver\_generalized\_shift}\
and {\tt \solver\_buckling}\ only)
is an \intentin\ scalar of type \REALDP\
that holds the shift, 
a value around which the wanted eigenvalues %of interest 
are situated.
%
\itt{left} is an \intentin\ scalar of type default \Integer\ 
that holds the number of wanted leftmost eigenpairs.
{\bf Restriction:} {$0 <$ \tt left + right $\le$ min(mep, n/2)},
where {\tt right} is zero for 
{\tt\solver\_standard}\ and {\tt\solver\_generalized}.
%
\itt{right} 
({\tt \solver\_standard\_shift}, {\tt \solver\_generalized\_shift}\
and {\tt \solver\_buckling}\ only)
is an \intentin\ scalar of type default \Integer\ 
that holds the number of wanted eigenvalues to the right of {\tt sigma}.
{\bf Restriction:} {\tt $0 < $ left + right $\le$ min(mep, n/2)}.
%
\itt{mep} is an \intentin\ scalar of type default \Integer\ 
that holds the size of the array {\tt lambda}.
See Section~\ref{sec:method} for guidance on
setting {\tt mep}.
{\bf Restriction:} 
{\tt mep} is not less than the number of wanted eigenpairs
(cf. {\tt left} and {\tt right}.
%
\itt{lambda(:)} is an \intentinout\ %rank-1 
array of type \REALDP\
and size {\tt mep} that is
used to store the computed eigenvalues.
After a successful completion of the computation
it contains eigenvalues in ascending order.
This array must not be changed by the user.
%
\itt{n} is an \intentin\ scalar of type default \Integer\ 
that holds the problem size.
{\bf Restriction:} {\tt n $\ge 1$}.
%
\itt{x(:,:)} is an \intentinout\ %rank-2 
array of package type,
and dimensions {\tt ldX} and {\tt mep} that is
used to store the computed eigenvectors.
The order of eigenvectors in {\tt x(:,:)}
is the same as the order of eigenvalues in {\tt lambda(:)}.
This array may only be changed by the user
before the first call to an eigensolver procedure
(see the description of {\tt options\%user\_x} in Section~\ref{sec:options}).
%
\itt{ldx} is an \intentin\ scalar of type default \Integer\ 
that holds the leading dimension of {\tt x(:,:)}.
{\bf Restriction:} {\tt ldx $\ge$ n}.
%
\itt{keep} is an \intentinout\ scalar of type 
{\tt \solver\_keepd} in the real version and
{\tt \solver\_keepz} in the complex version
that holds private data. 
%
\itt{options} is an \intentin\  scalar  of type {\tt \solver\_options}.
Its components offer the user a range of options,
see Section~\ref{sec:options}.
%
\itt{inform} is an \intentinout\ scalar of type 
{\tt \solver\_inform}. Its components provide information about the execution
of the subroutine, see Section~\ref{sec:inform}.
It must not be changed by the user.
%
\end{description}

\subsection{Terminating procedure}

{\bf
At the end of the computation, the memory 
allocated by the solver procedures
should be released
by making the following subroutine call:
}

\medskip

\hspace{8mm} {\tt \solver\_terminate( keep, inform )}

\begin{description}
%
\itt{keep} is an \intentinout\ scalar of type 
{\tt \solver\_keep}, optional. 
On exit, its components that are allocatable arrays will have been deallocated. 
%
\itt{inform} is an \intentinout\ scalar of type {\tt \solver\_inform}, 
optional.
On exit, its components that are allocatable arrays will have been deallocated. 
%
\end{description}

\section{Derived types}

\subsection{Derived data type for options}

\label{sec:options}

The derived data type
{\tt \solver\_options}
has the following components.

\bigskip
\noindent
{\bf Convergence control options}

\begin{description}
%
\itt{abs\_tol\_lambda} is a scalar of type %default \Double\ 
\REALDP\ that
holds an absolute tolerance used when testing the estimated eigenvalue 
error, see Section~\ref{sec:method}. 
The default value is 0. %{\tt abs\_tol = 0}.
Negative values are treated as the default.
%
\itt{abs\_tol\_residual} is a scalar of type \REALDP\ that
holds an absolute tolerance used when testing the residual, 
see Section~\ref{sec:method}.
The default value is 0.
Negative values are treated as the default.
%
\itt{max\_iterations} is a scalar of type default \Integer\ that
contains the maximum number of iterations to be performed.
The default value is 100. %{\tt max\_it = 100}.
%{\bf Restriction:} {\tt max\_it $\ge$ 0}.
%
\itt{rel\_tol\_lambda} is a scalar of type \REALDP\ that
holds a relative tolerance used when testing the estimated eigenvalue 
error, see Section~\ref{sec:method}. 
The default value is 0. 
Negative values are treated as the default.
%
\itt{rel\_tol\_residual} is a scalar of type \REALDP\ that
holds a relative tolerance used when testing the residual,
see Section~\ref{sec:method}. 
If both {\tt abs\_tol\_residual} and {\tt rel\_tol\_residual}
are set to 0, then the residual norms are not taken
into consideration by the convergence test,
see Section~\ref{sec:method}.
The default value is 0.
Negative values are treated as the default.
%
\itt{tol\_x} is a scalar of type \REALDP\ 
that holds a tolerance used when testing the estimated 
eigenvector error, see Section~\ref{sec:method}. 
If {\tt tol\_x} is set to zero, the eigenvector error is not estimated.
If a negative value is assigned, the tolerance is set to
{\tt sqrt(epsilon(lambda))}.
The default value is -1.0.
%
\end{description}

\medskip
\noindent
{\bf Printing options}

\begin{description}
%
\itt{print\_level} is a scalar of type default \Integer\ that
determines the amount of printing.
Possible values are:
%
\begin{tabular}{rcl}
$<0$ &:& no printing;\\
$0$ &:& error and warning messages only;\\
$1$ &:& the type (standard or generalized) and the size of the problem,
the number of eigenpairs \\ 
& & requested, the error tolerances and
the size of the subspace are printed before the iterations start;\\
$2$ &:& as $1$ but, for each eigenpair tested for convergence
(see Section~\ref{sec:method}), the iteration number,
the index of \\
& & 
the eigenpair, the
eigenvalue, whether it has converged, the residual norm, and the error
estimates \\
& & are printed;\\
$>2$ &:& as $1$ but with all eigenvalues, whether converged, residual norms
and eigenvalue/eigenvector\\ 
& & error estimates printed on each iteration. 
\end{tabular}

\noindent
The default value is 0. 
Note that for eigenpairs that are far from convergence,
`rough' error estimates are printed
(the estimates that are actually used by the stopping criteria,
see Section~\ref{sec:method}, only become available on the last few
iterations).
%
\itt{unit\_error} is a scalar of type default \Integer\ that
holds the unit number for error messages.
Printing is suppressed if {\tt unit\_error < 0}.
The default value is 6. 
%
\itt{unit\_diagnostic} is a scalar of type default \Integer\ that
holds the unit number for messages monitoring the convergence.
Printing is suppressed if {\tt unit\_diagnostics < 0}.
The default value is 6. 
%
\itt{unit\_warning} is a scalar of type default \Integer\ that
holds the unit number for warning messages.
Printing is suppressed if {\tt unit\_warning < 0}.
The default value is 6. 
%
\end{description}

\medskip
\noindent
{\bf Advanced options}

\begin{description}
%
\itt{left\_gap}
is a scalar of type \REALDP\ 
that is only used when
{\tt left} is non-zero, and
specifies the minimal acceptable distance
between the last computed left eigenvalue
and the rest of the spectrum.
For {\tt \solver\_standard} and {\tt \solver\_generalized},
the last computed left eigenvalue
is the rightmost of the computed ones,
and for the other procedures
it is the leftmost.
If set to a negative value $\delta$,
the minimal distance is taken as
$|\delta|$ times the average distance between the computed eigenvalues.
Note that for this option to have any effect,
the value of {\tt mep} must be larger than
{\tt left + right}: see Section~\ref{sec:method}
for further explanation.
The default value is 0.
%
\itt{max\_left}
is a scalar of type default \Integer\ that
holds the number of eigenvalues to the left from $\sigma$,
or a negative value, if this number is not known
(cf. \S\ref{sec:method}).
The default is {\tt max\_left = -1}.
%
\itt{max\_right}
is a scalar of type default \Integer\ that
holds the number of eigenvalues to the right from $\sigma$,
or a negative value, if this number is not known.
(cf. \S\ref{sec:method}).
The default is {\tt max\_right = -1}.
%
\itt{right\_gap}
is a scalar of type \REALDP\ 
that is only used by 
{\tt \solver\_standard\_shift}, {\tt \solver\_generalized\_shift}
and {\tt \solver\_buckling}
with a non-zero {\tt right}, and
has the same meaning as {\tt options\%left\_gap}
but for the rightmost computed eigenvalue.
The default value is 0.
%
\itt{user\_x} is a scalar of type default \Integer. 
If {\tt user\_x > 0} then the first {\tt user\_x} columns
of {\tt x(:,:)} will be used as initial guesses for eigenvectors.
Hence, if the user has good approximations
to some of the required eigenvectors, the computation time
may be reduced by putting these approximations
into the first {\tt user\_x} columns of {\tt x(:,:)}.
The default value is 0, 
i.e. the columns of {\tt x(:,:)} are overwritten by the solver.
{\bf Restriction:} if {\tt user\_x > 0} then
%{0 $\le$ \tt user\_x $\le$ m},
the first {\tt user\_x} columns in {\tt x(:,:)}
must be linearly independent.
%
\end{description}

\subsection{The derived data type for holding information}

\label{sec:inform}

The derived data type {\tt \solver\_inform} is used
to hold information from the execution of
the solver procedures.
The components are:

\begin{description}
%
\itt{flag} is a scalar of type default {\tt INTEGER} 
that is used as an error flag.
If a call is successful, {\tt flag} has value {\tt 0}.
A nonzero value of {\tt flag} indicates an error or a warning
(see Section~\ref{sec:err}).
%
\itt{iteration} is a scalar of type default {\tt INTEGER} that holds 
the number of iterations.
%
\itt{left}
is a scalar of type default {\tt INTEGER} that holds
the number of converged eigenvalues on the left,
i.e. the total number of converged eigenpairs for 
{\tt \solver\_standard} and {\tt \solver\_generalized},
and the number of the converged eigenvalues left of {\tt sigma}
for {\tt \solver\_standard\_shift}, {\tt \solver\_generalized\_shift}
and {\tt \solver\_buckling}.
%
\itt{next\_left}
is a scalar of type \REALDP\ that holds
the non-converged eigenvalue next to the last converged on the left
(cf. {\tt options\%left\_gap}).
%
\itt{next\_right}
is a scalar of type \REALDP\ that is used by
{\tt \solver\_standard\_shift}, {\tt \solver\_generalized\_shift}
and {\tt \solver\_buckling} only, and holds
the non-converged eigenvalue next to the last converged on the right
(cf. {\tt options\%right\_gap}).
%
\itt{non\_converged}
is a scalar of type default \Integer\ 
that holds the number of non-converged eigenpairs
(see Section~\ref{sec:err}).
%
\itt{right}
is a scalar of type default {\tt INTEGER} that is used by 
{\tt \solver\_standard\_shift}, {\tt \solver\_generalized\_shift}
and {\tt \solver\_buckling} only, and holds
the number of converged eigenvalues right of {\tt sigma}.
%
\itt{stat}
is a scalar of type default \Integer\ 
that holds the allocation status
(see Section~\ref{sec:err}).
%
\end{description}

\subsection{Error codes}

\label{sec:err}

A successful return from 
a solver procedure
is indicated 
by {\tt inform\%flag $=$ 0}.
A negative value indicates an error, a positive value indicates a warning;
{\tt inform\%data} provides further information
about some errors and warnings. 

\noindent
Possible negative values of {\tt inform\%flag}
are as follows:
%
\begin{description}
%
\item{~~-1}
\hskip 9pt
{\tt rci\%job}  is out-of-range.
%
\item{~~-9}
\hskip 7pt
{\tt n} is out-of-range.
%
\item{~-10}
\hskip 7pt
{\tt ldx} is out-of-range.
%
\item{~-11}
\hskip 7pt
{\tt left} is out-of-range.
%
\item{~-12}
\hskip 7pt
{\tt right} is out-of-range.
%
\item{~-13}
\hskip 7pt
{\tt mep} is less than 
the number of wanted eigenpairs.
%{\tt left} + {\tt right}.
%
\item{-100}
\hskip 4pt
Not enough memory;
{\tt inform\%stat} contains the value of the Fortran {\tt stat} parameter.
%
\item{-200}
\hskip 4pt
$B$ is not positive definite or {\tt user\_x > 0} and
linear dependent initial guesses were supplied.
%
\end{description}

\noindent
Possible positive values  are: 
%
\begin{description}
\item{1}
\hskip 9pt
The iterations have been terminated because no further improvement
in accuracy is possible (this may happen if $B$ or the preconditioner is
not positive definite, or if the components of the residual vectors
are so small that the round-off
errors make them essentially random).
The value of {\tt inform\%non\_converged} is set to the number
of non-converged eigenpairs.
\item{2}
\hskip 9pt
The maximum number of iterations {\tt max\_iterations} has been exceeded.
The value of {\tt inform\%non\_converged} is set to the number
of non-converged eigenpairs.
\item{3}
\hskip 9pt
The solver had run
out of storage space for the converged eigenpairs
before the gap in the spectrum 
required by {\tt options\%left\_gap} and/or {\tt options\%right\_gap}
was reached.
The value of {\tt inform\%non\_converged} is set to the number
of non-converged eigenpairs.
%
\end{description}

If the computation is terminated with the error code 2 or 3,
it can be resumed with larger values of {\tt max\_iterations} and/or {\tt mep}.
In this case the user should set {\tt options\%user\_X} to
{\tt info\%left $+$ info\%right}
and restart the reverse communication loop.
An alternative option is to use
one of the advanced solver procedures
from {\tt \advanced} or {\tt \engine}
that relegate the storage of computed eigenpairs and
the termination of the computation to the user.

\section{Method}
\label{sec:method}

{\tt \engine}, upon which {\tt\fullpackagename} is built,
implements a block iterative algorithm
based on the Jacobi-conjugate preconditioned gradients (JCPG) method
\cite{jcpg1,jcpg2}.
This algorithm simultaneously computes $m < n$ approximate eigenpairs,
where the block size $m$ exceeds the number $n_e$ of desired eigenpairs
for the sake of better convergence, namely,
$m = n_e + \min(10, 0.1 n_e)$.

An approximate eigenpair 
$\{x,\lambda\}$ is considered to have converged
if %all of 
the following three conditions are all satisfied:
%
\begin{enumerate}
%
\item
if {\tt options\%abs\_tol\_lambda} and 
{\tt options\%rel\_tol\_lambda}
are not both equal to zero, then
the estimated error in the approximate eigenvalue
must be less than or equal to

{\tt max(options\%abs\_tol\_lambda, 
$\delta$*options\%rel\_tol\_lambda)},

where $\delta$ is the estimated average distance
between eigenvalues.
\item
if {\tt options\%tol\_x} is not zero, then
the estimated sine of the angle between
the approximate eigenvector and the invariant subspace
corresponding to the eigenvalue 
approximated by $\lambda$
must be less than or equal to {\tt options\%tol\_x}.
%
\item
if {\tt options\%abs\_tol\_residual} and 
{\tt options\%rel\_tol\_residual}
are not both equal to zero, then
the Euclidean norm of the residual,
$\|A x - \lambda B x\|_2$,
must be less than or equal to

{\tt max(options\%abs\_tol\_residual, 
options\%rel\_tol\_residual*$\|\lambda B x\|_2$)}.
%
\end{enumerate}
%
The extra eigenpairs are not checked for convergence,
as their role is purely auxiliary.

If the gap %distance 
between the last computed eigenvalue 
and the rest of the spectrum is small,
then the accuracy of the corresponding eigenvector may be very low.
To prevent this from happening,
the user should set the eigenpairs storage size {\tt mep}
to a value that is larger than the number of desired eigenpairs,
and set the options 
{\tt options\%left\_gap}
and
{\tt options\%right\_gap}
to non-zero values $\delta_l$ and $\delta_r$.
These values
determine the size of the minimal acceptable gaps
between the computed eigenvalues and the rest of the spectrum,
$\delta_l$ referring to either leftmost eigenvalues
(for {\tt \solver\_standard} and {\tt \solver\_generalized} only)
or those to the left of the shift {\tt sigma},
and $\delta_r$
to those to the right of the shift {\tt sigma}.
Positive values of $\delta_l$ and $\delta_r$
set the gap explicitely,
and negative values
require the gap to be not less than their absolute value times
the average distance between the computed eigenvalues.
A recommended value of $\delta_l$ and $\delta_r$ is $-0.1$.
The value of {\tt mep} %virtually does not affect 
has little effect on
the speed of computation,
hence it might be set to any reasonably large value.
The larger the value of {\tt mep}, 
the larger the size of an eigenvalue cluster
for which accurate eigenvectors can be computed, notably:
to safeguard against clusters of size up to $k$,
it is sufficient to set {\tt mep} to the number of desired eigenpairs
plus $k - 1$.

When using the solver procedures that employ the shift-and-invert technique,
it is very important to ensure that the numbers of wanted eigenvalues
each side of the shift do not exceed the actual numbers of these eigenvalues,
as the eigenpairs `approximating' non-existing eigenpairs of the problem
will not converge.
It is therefore strongly recommended that the user employs 
a linear system solver that performs
the LDLT
factorization of %for solving 
the shifted system,
e.g. {\tt HSL\_MA97} or {\tt SPRAL\_SSIDS}.
The LDLT factorization of the matrix
$A - \sigma B$ consists in finding a lower triangular
matrix $L$, a block-diagonal matrix $D$
with $1\times 1$ and $2\times 2$ blocks on the main diagonal
and a permutation matrix $P$
such that $P^T(A - \sigma B)P = L D L^T$.
By inertia theorem,
the number of eigenvalues to the left and right from 
the shift $\sigma$
is equal to the number of negative and positive eigenvalues of $D$,
which allows quick computation of the eigenvalue numbers
each side of the shift. %(see the example in Section~\ref{sec:ex2}).

\thebibliography{1}

\bibitem{report}
E.~E.~Ovtchinnikov and J.~Reid.
A preconditioned block conjugate gradient
algorithm for computing extreme eigenpairs
of symmetric and Hermitian problems.
\report, 2010.

\bibitem{jcpg1}
E.~E.~Ovtchinnikov,
{\em Jacobi correction equation, line search and
conjugate gradients in Hermitian eigenvalue computation I:
Computing an extreme eigenvalue},
SIAM J. Numer. Anal., {\bf 46}:2567--2592, 2008.
\bibitem{jcpg2}
E.~E.~Ovtchinnikov,
{\em Jacobi correction equation, line search and
conjugate gradients in Hermitian eigenvalue computation II:
Computing several extreme eigenvalues},
SIAM J. Numer. Anal., {\bf 46}:2593--2619, 2008.

%\hslexample

\section{Examples}

\subsection{Preconditioning example}
\label{sec:ex.prec}

The following code 
computes the 5 leftmost eigenpairs of 
the matrix $A$ of order 100 that approximates 
the two-dimensional Laplacian operator
on a 20-by-20 grid.
One forward and one backward Gauss-Seidel update
are used for preconditioning,
which halves the number of iterations
compared with solving the same problem without preconditioning.
A Fortran90 module {\tt laplace2d}, supplied with the package,
contains a subroutine {\tt apply\_2d\_laplacian}
that multiplies a block of vectors by $A$,
%A Fortran90 module {\tt gauss\_seidel\_preconditioner}, 
%supplied with the package,
%contains 
and a subroutine 
%{\tt apply\_preconditioner}
{\tt apply\_gauss\_seidel\_step}
that computes $y = T x$ for a block of vectors $x$
by applying one forward and one backward update
of the Gauss-Seidel method to the system $A y = x$.
\verbatiminput{examples/Fortran/ssmfe/precond_ssmfe.f90}
This code produces the following output:
\begin{verbatim}
  6 eigenpairs converged
 lambda( 1) = 4.4676695E-02
 lambda( 2) = 1.1119274E-01
 lambda( 3) = 1.1119274E-01
 lambda( 4) = 1.7770878E-01
 lambda( 5) = 2.2040061E-01
 lambda( 6) = 2.2040061E-01
\end{verbatim}

Note that the code computed one extra eigenpair
because of the insufficient gap between the 5th and 6th
eigenvalues.

\subsection{Shift-and-invert example}
\label{sec:ex.si}

The following code 
computes the eigenpairs of 
the matrix of order 64 that approximates 
the two-dimensional Laplacian operator
on 8-by-8 grid
with eigenvalues near the shift {\tt sigma $=1.0$}.
For the shifted solve, LAPACK subroutines {\tt DSYTRS} and
{\tt DSYTRF} are used,
which perform the LDLT-factorization and
the solution of the factorized system respectively.
The matrix of the discretized Laplacian is computed
by the subroutine {\tt compute\_2d\_laplacian matrix}
from the Fortran90 module {\tt laplace2d}
supplied with the package.
A Fortran90 module {\tt ldlt} supplied with the package
contains a Fortran90 function {\tt num\_neg\_D}
that counts the number of negative eigenvalues of
the D-factor.
\verbatiminput{examples/Fortran/ssmfe/shift_invert.f90}
This code produces the following output:
\begin{verbatim}
 Eigenvalues near  1.00E+00
 lambda( 1) = 2.4122952E-01
 lambda( 2) = 5.8852587E-01
 lambda( 3) = 5.8852587E-01
 lambda( 4) = 9.3582223E-01
 lambda( 5) = 1.1206148E+00
 lambda( 6) = 1.1206148E+00
 lambda( 7) = 1.4679111E+00
 lambda( 8) = 1.4679111E+00
 lambda( 9) = 1.7733184E+00
\end{verbatim}

\subsection{Hermitian example}
\label{sec:ex.h}

The following code 
computes the 5 leftmost eigenpairs of 
%the matrix $A$ of order 80 that approximates 
the differential operator $i \frac{d}{dx}$
acting in the space of periodic functions
discretized by central differences on a uniform mesh
of 80 steps.
\verbatiminput{examples/Fortran/ssmfe/hermitian.f90}
This code produces the following output:
\begin{verbatim}
  5 eigenpairs converged
 lambda( 1) = -2.0000000E+00
 lambda( 2) = -1.9938347E+00
 lambda( 3) = -1.9938347E+00
 lambda( 4) = -1.9753767E+00
 lambda( 5) = -1.9753767E+00
\end{verbatim}

\end{document}



