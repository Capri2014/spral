\documentclass{spral}

\usepackage{pifont}
\newcommand{\cmark}{\ding{51}}
\newcommand{\xmark}{\ding{55}}

\newcommand{\packagename}{SSIDS}
\newcommand{\version}{1.0.0}
\newcommand{\versiondate}{17 March 2014}
\newcommand{\purpose}{
This package solves one or more sets of $n\times n$
sparse {\bf symmetric} equations  ${AX = B}$ using a multifrontal method on an
\textbf{NVIDIA GPU}.
The package covers the following cases:
\begin{enumerate}
\item $A$ is {\bf indefinite}.
SSIDS computes the sparse factorization
$$
   A =  PLD(PL)^T
$$
where $P$ is a permutation matrix, $L$ is unit lower triangular,
and $D$ is block diagonal with blocks of size $1 \times 1 $
and $2 \times 2$.
\item $A$ is {\bf positive definite}.
SSIDS computes the {\bf sparse Cholesky factorization}
$$
   A =  PL(PL)^T
$$
where $P$ is a permutation matrix and $L$ is lower triangular.
\textit{However, this will be slower than a dedicated Cholesky solver.}
\end{enumerate}

SSIDS has been designed to return bit-compatible results.

An option exists to scale the matrix. In this case, the factorization of
the scaled matrix  $ {\overline{A} = S A S}$ is computed,
where ${S}$ is a diagonal scaling matrix.
}


\begin{document}

\title{Sparse Symmetric Indefinite Direct Solver}
\author{
   Jonathan Hogg (STFC Rutherford Appleton Laboratory) \\
   Evgueni Ovtchinnikov (STFC Rutherford Appleton Laboratory) \\
   Jennifer Scott (STFC Rutherford Appleton Laboratory)
}
\pkglang{Fortran}
\maketitle
\thispagestyle{firststyle}

\section*{Major version history}
\begin{description}
\item[2014-03-17 Version 1.0.0] Initial release
\end{description}

%%%%%%%%%%%%%%%%%%%%%% installation %%%%%%%%%%%%%%%%%%%%%%

\section{Installation}
Please see the dedicated SPRAL install document. In particular note that:
\begin{itemize}
   \item A CUDA compiler (\texttt{nvcc}) is required.
   \item A METIS library is required.
   \item A BLAS library is required.
   \item For multi-GPU or multi-stream work, OpenMP must be enabled
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%% how to use %%%%%%%%%%%%%%%%%%%%%%%%

\section{Usage overview}

\subsection{Calling sequences}

Access to the module requires a {\tt USE} statement \\ \\
\indent\hspace{8mm}{\tt use spral\_ssids} \\

\medskip

\noindent
The following procedures are available to the user:
\begin{itemize}
\item {\tt ssids\_analyse} accepts the matrix data in compressed
sparse column format and optionally checks it for duplicates and  out-of-range entries.
The user may supply an elimination order; otherwise
one is generated. Using this elimination order,
{\tt ssids\_analyse}  analyses the sparsity pattern of
the matrix and prepares the data structures for the factorization.

 \item {\tt ssids\_analyse\_coord} is an alternative to
{\tt ssids\_analyse} that may be used if the user has
the matrix data held in coordinate
format. Again, the user may supply an elimination order; otherwise
one is generated. {\tt ssids\_analyse\_coord}
checks the matrix data  for duplicates and  out-of-range entries,
stores
it in compressed sparse column format and then proceeds
in the same way as {\tt ssids\_analyse}.

\item {\tt ssids\_factor} uses the data structures
set up by {\tt ssids\_analyse} to compute a sparse
factorization. More than one call to  {\tt ssids\_factor}
may follow a call to {\tt ssids\_analyse} (allowing more than
one matrix with the same sparsity pattern but different
numerical values to be factorized without multiple calls to
{\tt ssids\_analyse}).
An option exists to scale the matrix.

\item {\tt ssids\_solve} uses the computed factors generated
by  {\tt ssids\_factor}
to solve systems ${AX= B}$
for one or more right-hand sides $B$.
Multiple calls to {\tt ssids\_solve} may follow a call to
{\tt ssids\_factor}.
An option is available to perform a partial solution.

\item {\tt ssids\_finalise} should be called after all other calls
are complete for a problem (including after an error
return that does not allow the computation
to continue). It frees memory referenced by components of
the derived data types.
\end{itemize}

\noindent
In addition, the following routines may be called:
\begin{itemize}
\item {\tt ssids\_free} may be called to free memory associated with {\tt akeep}
or {\tt fkeep} when a call to {\tt ssids\_finalise} is not appropriate (for
example, if a further factorization is to be performed for a matrix with the
same sparsity pattern).
\item {\tt ssids\_enquire\_posdef} may be called
in the  positive-definite case to obtain the pivots used.
\item {\tt ssids\_enquire\_indef} may be called
in the indefinite case to obtain the pivot sequence used by the factorization
and the entries of  ${D}^{-1}$.
\item {\tt ssids\_alter} may be called in the indefinite case to alter
the entries of ${D}^{-1}$.
Note that this means that  $PLD(PL)^T$ is no longer
a factorization of $A$.

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%% derived types %%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Derived types} \label{derived types}

For each problem, the user must employ the derived types defined by the
module to declare scalars of the types
{\tt ssids\_options}, {\tt ssids\_inform}, {\tt ssids\_akeep}, and {\tt ssids\_fkeep}.
The following pseudo-code illustrates this.
\begin{verbatim}
      use spral_ssids
      ...
      type (ssids_options) :: options
      type (ssids_inform) :: inform
      type (ssids_akeep) :: akeep
      type (ssids_fkeep) :: fkeep
      ...
\end{verbatim}
The components of {\tt ssids\_options} and {\tt ssids\_inform} are explained
in Sections~\ref{typeoptions} and \ref{typeinform}.
The components of {\tt ssids\_akeep} and {\tt ssids\_fkeep} are used to pass
data between the subroutines of the package and must not be altered by the user.

\subsection{Achieving bit-compatibility} \label{bitcompat}
Care has been taken to allow bit-compatibility to be achieved using this solver.
That is to say consecutive runs with the same data should produce exactly
the same solution.

\subsection{Optional arguments}\label{Optional arguments}

We use square brackets {\tt [ ]} to indicate {\it optional} arguments.
In each
call, optional arguments follow the argument {\tt inform}.  Since we
reserve the right to add additional optional arguments in future
releases of the code, {\bf we strongly recommend that all optional
arguments be called by keyword, not by position}.

\subsection{Integer, real and package types}\label{Integer kinds}

{\tt INTEGER} denotes default {\tt INTEGER} and
{\tt INTEGER(long)} denotes {\tt INTEGER(kind=selected\_int\_kind(18))}.

\noindent
{\tt REAL} denotes default real if the single precision version, and double
precision real if the double precision is being used.
We use the term {\bf package type} to mean
default real if the single precision version is being used,
double precision real for the double precision version.

\subsection{Data formats} \label{dataformats}

\begin{figure}
   \caption{ \label{format eg}
      Data format example matrix
   }
   $$
      \left( \begin{array}{ccccc}
         1.1 & 2.2 &     & 3.3 &     \\
         2.2 &     & 4.4 &     &     \\
             & 4.4 & 5.5 &     & 6.6 \\
         3.3 &     &     & 7.7 & 8.8 \\
             &     & 6.6 & 8.8 & 9.9
      \end{array} \right)
   $$
\end{figure}

\subsubsection{Compressed Sparse Column (CSC) Format} \label{cscformat}
This standard data format consists of the following data:
\begin{verbatim}
   integer                   :: n      ! size of matrix
   integer, size(n+1)        :: ptr    ! column pointers
   integer, size(ptr(n+1)-1) :: row    ! row indices
   real,    size(ptr(n+1)-1) :: val    ! numerical values
\end{verbatim}
Non-zero matrix entries are ordered by increasing column index and stored in
the arrays \texttt{row(:)} and \texttt{val(:)} such that \texttt{row(k)} gives
the row number and \texttt{val(k)} gives the value of the \texttt{k}-th entry.
The \texttt{ptr(:)} array stores column pointers such that \texttt{ptr(i)} is
the first entry in the \texttt{i}-th column, and \texttt{ptr(n+1)} is one more
than the total number of entries.
Entries that are zero, including those on the diagonal, need not be specified.

\texttt{SSIDS} requires that only the lower triangluar entries are supplied,
and there are no duplicate entries. If the \texttt{check} argument to
\texttt{ssids\_analyse()} is \texttt{.true.}, out of range entries (including
those in the upper triangle) will be discarded and any duplicates will be
summed.

To illustrate the format, the following arrays describe the matrix shown in
Figure~\ref{format eg}.
\begin{verbatim}
   n = 5
   ptr(1:6) = (/ 1,             4,   5,        7,        9,    10 /)
   row(1:9) = (/ 1,   2,   4,   3,   3,   5,   4,   5,   5 /)
   val(1:9) = (/ 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9 /)
\end{verbatim}

\subsubsection{Coordinate Format} \label{coordformat}
This standard data format consists of the following data:
\begin{verbatim}
   integer           :: n     ! size of matrix
   integer           :: ne    ! number of non-zero entries
   integer, size(ne) :: row   ! row indices
   integer, size(ne) :: col   ! column indices
   real,    size(ne) :: val   ! numerical values
\end{verbatim}
The arrays should be set such that the \texttt{k}-th entry is in row
\texttt{row(k)} and column \texttt{col(k)} with value \texttt{val(k)}.
Entries that are zero, including those on the diagonal, need not be specified.

\texttt{SSIDS} requires that each entry should be present \textbf{only} in the
lower \textit{or} upper triangle. Entries present in both will be summed, as
will any duplicate entries. Out-of-range entries are ignored.

To illustrate the format, the following arrays describe the matrix shown in
Figure~\ref{format eg}.
\begin{verbatim}
   n = 5
   ne = 9
   row(1:9) = (/ 1,   2,   3,   4,   3,   5,   4,   5,   5 /)
   col(1:9) = (/ 1,   1,   2,   1,   3,   3,   4,   4,   5 /)
   val(1:9) = (/ 1.1, 2.2, 4.4, 3.3, 5.5, 6.6, 7.7, 8.8, 9.9 /)
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%% argument lists %%%%%%%%%%%%%%%%%%%%%%%%

\section{Basic Subroutines}

%%%%%%%%% analyse subroutine %%%%%%

\subsection{\texttt{ssids\_analyse()} and \texttt{ssids\_analyse\_coord()}}\label{analyse}

\textbf{
   To analyse the sparsity pattern and prepare for the factorization,
   \begin{itemize}
      \item[] for Compessed Sparse Column (CSC) format:
      \vspace*{0.1cm} \\
      \texttt{ \hspace*{0.2cm}
         call ssids\_analyse(check,n,ptr,row,akeep,options,inform[,order,val])
      }
      \item[] for Coordinate format:
      \vspace*{0.1cm} \\
      \texttt{ \hspace*{0.2cm}
         call ssids\_analyse\_coord(n,ne,row,col,akeep,options,inform[,order,val])
      }
   \end{itemize}
}

\noindent
Matrix data should be supplied as described in Section~\ref{dataformats}.

\noindent

\vspace*{-3mm}
\begin{description}

\item[\texttt{check}] is an \intentin\ scalar of
type  {\tt LOGICAL}. If set to {\tt .true.} the matrix
data is checked for errors and the cleaned matrix
(duplicates are summed and out-of-range entries
discarded) is stored in {\tt akeep}.
Otherwise, no checking of the matrix data is carried out
and {\tt ptr} and {\tt row} must be passed unchanged to the factorization routines.

\item[\texttt{n}{\rm ,} \texttt{ptr(:)}{\rm ,} \texttt{row(:)}] are \intentin\ 
   variables of type {\tt INTEGER} specifying the lower triangular part of $A$
   in CSC format (see Section~\ref{cscformat}).

\item[\texttt{n}{\rm ,} \texttt{ne}{\rm ,} \texttt{row(:)}{\rm ,} \texttt{col(:)}]
   are \intentin\ variables of type {\tt INTEGER} specifying the lower
   (or upper) triangular part of $A$ in Coordinate format (see Section~\ref{coordformat}).

\item[\texttt{akeep}] is an \intentout\ scalar of type
{\tt ssids\_akeep}. It is used to hold data about the problem being
solved and must be passed unchanged to the other subroutines.

\item[\texttt{options}] is an \intentin\ scalar of type {\tt ssids\_options}
(see Section~\ref{typeoptions}).

\item[\texttt{inform}] is an \intentout\ scalar of type
{\tt ssids\_inform}. Its components provide information about the execution
of the subroutine, as explained in Section~\ref{typeinform}.

\item[\texttt{order(:)}] is an optional \intentinout\ array of type
{\tt INTEGER} and size {\tt n}. If {\tt options\%ordering}$=${\tt 0},
{\tt order(:)} must be present and {\tt order(i)} must hold the  position of
variable $i$  in the elimination order. On exit, {\tt order(:)} contains the
elimination order that {\tt ssids\_factor} will be given (it is passed to these
routines as part of {\tt akeep}); this order may give slightly more fill-in
than the user-supplied order and, in the indefinite case, may be modified by
{\tt ssids\_factor} to maintain numerical stability. 

\item[\texttt{val(:)}] is an optional \intentin\ array of package type giving
the numerical values of the matrix as described in Section~\ref{dataformats}.
{\tt val} must be present if a matching-based elimination ordering is required
({\tt options\%ordering$=$2}), and is otherwise ignored.

\end{description}


%%%%%%%%% factorize subroutine %%%%%%
\subsection{\texttt{ssids\_factor()}} \label{factorize}
\textbf{To factorize the matrix,
   \vspace*{0.1cm} \\
   \texttt{ \hspace*{0.2cm}
      call ssids\_factor(posdef,val,akeep,fkeep,options,inform[,scale,ptr,row])
   }
}

\begin{description}
\item[\texttt{posdef}] is an \intentin\ scalar of type {\tt LOGICAL} that
must be set to {\tt .true.} if the matrix is positive-definite, and
{\tt .false.} if it is indefinite.

\item[\texttt{val(:)}] is an \intentin\ array of package type that must hold
the numerical values of the matrix as described in Section~\ref{dataformats}.

\item[\texttt{akeep}]  is an \intentin\ scalar of type
{\tt ssids\_akeep} that must be unchanged since the
call to {\tt ssids\_analyse()} or {\tt ssids\_analyse\_coord()}.

\item[\texttt{fkeep}]  is an \intentinout\ scalar of type
{\tt ssids\_fkeep}. It is used to hold data about the problem being
solved and must be passed unchanged to the other subroutines.

\item[\texttt{options}] is an \intentin\ scalar of type {\tt ssids\_options}
(see Section~\ref{typeoptions}).

\item[\texttt{inform}] is an \intentout\ scalar of type
{\tt ssids\_inform}. Its components provide information about the execution
of the subroutine, as explained in Section~\ref{typeinform}.

\item[\texttt{scale(:)}] is an optional \intentinout\ array of type {\tt REAL}
and size {\tt n}. If present, it must contain  the diagonal
entries of the scaling matrix ${S}$ and is unchanged on exit.

\item[\texttt{ptr(:)}] and {\tt row(:)} are optional \intentin\ arrays of
type {\tt INTEGER}. They are only accessed if {\tt ssids\_analyse()} was called
with {\tt check} set to {\tt .false.}.
In this case, they must both be present and  must be unchanged since that call.

\end{description}

%%%%%%%%% solve subroutine %%%%%%
\subsection{\texttt{ssids\_solve()}} \label{solve}
\textbf{ To solve the linear system $AX=B$, after a call to
   \texttt{ssids\_factor()},
   \begin{itemize}
      \item[] for a single right-hand side:
      \vspace*{0.1cm} \\
      \texttt{ \hspace*{0.2cm}
         call ssids\_solve(x1,akeep,fkeep,options,inform[,job])
      }
      \item[] for one or more right-hand sides:
      \vspace*{0.1cm} \\
      \texttt{ \hspace*{0.2cm}
         call ssids\_solve(nrhs,x,ldx,akeep,fkeep,options,inform[,job])
      }
   \end{itemize}
}

\noindent
Partial solutions may be performed by appropriately setting the optional
parameter {\tt job}.

\begin{description}
\item[\texttt{x1(:)}] is an \intentinout\ array of package type and size
\texttt{n}. It must be set such that \texttt{x1(i)} holds the component of
the right-hand side for variables \texttt{i}. On exit, \texttt{x1(i)} holds the
solution for variable \texttt{i}.

\item[\texttt{nrhs}] is an \intentin\ scalar of type {\tt INTEGER} that holds
the number of right-hand sides.

\item[\texttt{x(:,:)}] is an \intentinout\ array of package type with extents
\texttt{ldx} and \texttt{rhs}. It must be set so that \texttt{x(i,j)} holds the
component of the right-hand side for variable \texttt{i} to the \texttt{j}-th
system. On exit, \texttt{x(i,j)} holds the solution for variable \texttt{i} to
the \texttt{j}-th system.

\item[\texttt{ldx}] is an \intentin\ scalar of type {\tt INTEGER} that must be
set to the first extent of array \texttt{x}.

\item[\texttt{akeep}]  is an \intentin\ scalar of type {\tt ssids\_akeep} that
must be unchanged since the last call to {\tt ssids\_factor()}.

\item[\texttt{fkeep}]  is an \intentin\ scalar of type {\tt ssids\_fkeep} that
must be unchanged since the last call to {\tt ssids\_factor()}.

\item[\texttt{options}] is an \intentin\ scalar of type {\tt ssids\_options}
(see Section~\ref{typeoptions}).

\item[\texttt{inform}] is an \intentout\ scalar of type
{\tt ssids\_inform}. Its components provide information about the execution
of the subroutine, as explained in Section~\ref{typeinform}.

\item[\texttt{job}] is an optional  \intentin\ scalar of
type  {\tt INTEGER}. If absent, ${AX = B}$ is solved.
In the positive-definite case, the Cholesky factorization
that has been computed may be expressed in the form
\[ {SAS} = ({PL})({PL})^T \]
where $P$ is a permutation matrix and $L$ is lower triangular.
In the indefinite case, the factorization
that has been computed may be expressed in the form
\[ {S AS} = ({PL}){D}({PL})^T \]
where $P$ is a permutation matrix, $L$ is unit lower triangular,
and $D$ is block diagonal with blocks of order 1 and 2.
$S$ is a diagonal scaling matrix ($S$ is equal to the identity,
if \texttt{options\%scaling=0} and
{\tt scale} is not present on the last call to {\tt ssids\_factor}).
A partial solution may be computed by setting {\tt job} to have
one of the following values:
\begin{description}
\item[\texttt{1}] for solving ${PLX} = {SB}$
\item[\texttt{2}] for solving ${DX} = {B}$ (indefinite case only)
\item[\texttt{3}] for solving $({PL})^T{S^{-1}X} = {B}$
\item[\texttt{4}] for solving $D({PL})^T{S^{-1}X} = {B}$ (indefinite case only)
\end{description}
{\bf Note:} Depending on the value of \texttt{options\%use\_gpu\_solve} and
\texttt{options\%presolve}, some values of \texttt{job} are invalid, as shown
in the below table.

\begin{tabular}{ccc|ccccc}
   \hline
   & \texttt{options\%} & \texttt{options\%} & \texttt{job} & \multicolumn{4}{c}{\texttt{job}$=$} \\
   \texttt{posdef} & \texttt{use\_gpu\_solve} & \texttt{presolve} & Absent & {\tt 1} & {\tt 2} & {\tt 3} & {\tt 4} \\
   \hline
   Either & \texttt{.false.} & 0 & \cmark & \cmark & \cmark & \cmark & \cmark \\
   Either & \texttt{.false.} & 1 & \multicolumn{5}{c}{Invalid combination} \\
   \texttt{.true.} & \texttt{.true.} & 0 & \xmark & \xmark & - & \xmark & - \\
   \texttt{.true.} & \texttt{.true.} & 1 & \cmark & \cmark & - & \cmark & - \\
   \texttt{.false.} & \texttt{.true.} & 0 or 1 & \cmark & \cmark & \xmark & \xmark & \cmark \\
   \hline
\end{tabular}

\end{description}

%%%%%%% termination subroutine %%%%%%

\subsection{\texttt{ssids\_free()}}
\textbf{To free memory and resources,
   \begin{itemize}
      \item[] allocated by \texttt{ssids\_analyze()} or \texttt{ssids\_analyze\_coord()}:
      \vspace*{0.1cm} \\
      \texttt{ \hspace*{0.2cm}
         call ssids\_free(akeep,cuda\_error)
      }
      \item[] allocated by \texttt{ssids\_factor()}:
      \vspace*{0.1cm} \\
      \texttt{ \hspace*{0.2cm}
         call ssids\_free(fkeep,cuda\_error)
      }
      \item[] both at once:
      \vspace*{0.1cm} \\
      \texttt{ \hspace*{0.2cm}
         call ssids\_free(akeep,fkeep,cuda\_error)
      }
   \end{itemize}
}
Once all other calls are complete for a problem or after an error
return that does not allow the computation to continue,
a call should be made to free memory and CUDA resources allocated by SSIDS and
associated with the structures {\tt akeep} and/or {\tt fkeep} using calls to
\texttt{ssids\_free}.

\begin{description}

\item[\texttt{akeep}] is an \intentinout\ scalar  of type {\tt ssids\_akeep}
that must be passed unchanged.
On exit, allocatable components will have been deallocated, and CUDA resources
released.

\item[\texttt{fkeep}] is an \intentinout\ scalar  of type {\tt ssids\_fkeep}
that must be passed unchanged.
On exit, allocatable components will have been deallocated, and CUDA resources
released.

\item[\texttt{cuda\_error}] is an \intentout\ scalar of type default integer.
On exit, a non-zero value gives a CUDA error code. This may indicate either
a failure to deallocate GPU memory, or a pre-existing CUDA error condition.
Such a pre-existing error condition may have resulted from either user or
\texttt{SSIDS} code.

\end{description}

\section{Advanced subroutines}

%%%%%%% enquire subroutine %%%%%%

\subsection{\texttt{ssids\_enquire\_posdef()}}
\textbf{To obtain the matrix $D$ following a positive-definite factorization,
   \vspace*{0.1cm} \\
   \texttt{ \hspace*{0.2cm}
      call ssids\_enquire\_posdef(akeep,fkeep,options,inform,d)
   }
}

\begin{description}

\item[\texttt{akeep}]  is an \intentin\ scalar of type {\tt ssids\_akeep} that
must be unchanged since the call to {\tt ssids\_factor()}.

\item[\texttt{fkeep}]  is an \intentin\ scalar of type {\tt ssids\_fkeep} that
must be unchanged since the call to {\tt ssids\_factor()}.

\item[\texttt{options}] is an \intentin\ scalar of type {\tt ssids\_options}
(see Section~\ref{typeoptions}).

\item[\texttt{inform}] is an \intentout\ scalar of type
{\tt ssids\_inform}. Its components provide information about the execution
of the subroutine, as explained in Section~\ref{typeinform}.

\item[\texttt{d(:)}] is an  \intentout\ rarray of type {\tt  REAL} and
size {\tt n}. The {\tt i}-th diagonal entry of $D$ will be placed in {\tt d(i)}.

\end{description}
%%%%%%% enquire subroutine %%%%%%

\subsection{\texttt{ssids\_enquire\_indef()}}
\textbf{To obtain the matrix $D^{-1}$ and/or the pivot order following an
   indefinite factorization,
   \vspace*{0.1cm} \\
   \texttt{ \hspace*{0.2cm}
     call ssids\_enquire\_indef(akeep,fkeep,options,inform[,piv\_order,d])
   }
}

\begin{description}

\item[\texttt{akeep}]  is an \intentin\ scalar of type {\tt ssids\_akeep} that
must be unchanged since the call to {\tt ssids\_factor()}.

\item[\texttt{fkeep}]  is an \intentin\ scalar of type {\tt ssids\_fkeep} that
must be unchanged since the call to {\tt ssids\_factor()}.

\item[\texttt{options}] is an \intentin\ scalar of type {\tt ssids\_options}
(see Section~\ref{typeoptions}).

\item[\texttt{inform}] is an \intentout\ scalar of type
{\tt ssids\_inform}. Its components provide information about the execution
of the subroutine, as explained in Section~\ref{typeinform}.

\item[\texttt{piv\_order(:)}] is an optional \intentout\ array of type
{\tt INTEGER} and size {\tt n}. If present, on exit
$|\texttt{piv\_order(i)}|$ gives the position of vairable {\tt i} in the pivot
order. The sign will be positive if {\tt i} is a $1\times1$ pivot, and negative
if {\tt i} is part of a $2 \times 2$ pivot.

\item[\texttt{d(:,:)}] is an optional \intentout\ array of package type with
extents {\tt 2} and {\tt n}.
If present, on exit diagonal entries of ${D}^{-1}$ will be placed
in {\tt d(1,i)}, {\tt i = 1,2,\ldots,n},
the off-diagonal entries  of ${D}^{-1}$ will be placed in
{\tt d(2,i)}, {\tt i = 1,2,\ldots,n-1}, and
{\tt d(2,n)} will be set to zero.

\end{description}


%%%%%%% alter subroutine %%%%%%

\subsection{\texttt{ssids\_alter()}}
\textbf{To alter ${\bf D}^{-1}$ following an indefinite factorization,
   \vspace*{0.1cm} \\
   \texttt{ \hspace*{0.2cm}
      call ssids\_alter(d,akeep,fkeep,options,inform)
   }
}

\begin{description}

\item[\texttt{d(:,:)}] is an \intentin\ array of package type with
extents {\tt 2}  and {\tt n}. The diagonal entries
of ${D}^{-1}$ will be altered to {\tt d(1,i)}, {\tt i = 1,2,...,n},
and the off-diagonal entries will be altered to
{\tt d(2,i)}, {\tt i = 1,2,...,n-1} (and $PLD(PL)^T$ will no longer be
a factorization of $A$).

\item[\texttt{akeep}]  is an \intentin\ scalar of type {\tt ssids\_akeep} that
must be unchanged since the call to {\tt ssids\_factor()}.

\item[\texttt{fkeep}]  is an \intentinout\ scalar of type {\tt ssids\_fkeep}
that must be unchanged since the call to {\tt ssids\_factor()}.

\end{description}

%%%%%%%%%%% options type %%%%%%%%%%%

\section{Derived types}
\subsection{\texttt{ssids\_options}}
\label{typeoptions}

The derived data type {\tt ssids\_options}
is used to specify solver options. The components, which are automatically
given default values in the definition of the type, are: \\

%%%%%%%%%%%%
\noindent {\bf Printing options}

\begin{description}

\item[\texttt{print\_level}] is a scalar of type  {\tt INTEGER}
that is used to controls the level of  printing. The different levels are:
\begin{description}
\item{\tt $<$ 0 } No printing.
\item{\tt = 0 } Error and warning messages only.
\item{\tt = 1 } As 0, plus basic diagnostic printing.
\item{\tt $>$ 1 } As 1, plus some additional diagnostic printing.
\end{description}
The default is {\tt print\_level$=$\tt 0}.

\item[\texttt{unit\_diagnostics}] is a scalar  of type
{\tt INTEGER} that holds the
unit number for diagnostic printing. Printing is suppressed if
{\tt unit\_diagnostics$<0$}.
The default is {\tt unit\_diagnostics$=$6}.

\item[\texttt{unit\_error}] is a scalar of type  {\tt INTEGER} that holds the
unit number for error messages.
Printing of error messages
is suppressed if {\tt unit\_error$<$0}.
The default is {\tt unit\_error$=$6}.

\item[\texttt{unit\_warning}] is a scalar  of type  {\tt INTEGER} that holds the
unit number for warning messages.
Printing of warning messages is suppressed if {\tt unit\_warning$<$0}.
The default is {\tt unit\_warning$=$6}.

\end{description}



%%%%%%%%%%%%
\noindent {\bf Options used by {\tt ssids\_analyse()} and
{\tt ssids\_analyse\_coord()}}

\begin{description}

\item[\texttt{ordering}] is a scalar of
type  {\tt INTEGER}. If set to {\tt 0}, the user
must supply an elimination order in {\tt order}; otherwise
an elimination order will be computed by {\tt ssids\_analyse}
or {\tt ssids\_analyse\_coord}.
The options are:
\begin{description}
\item{} {\tt 0} User-supplied ordering is used.
\item{} {\tt 1} METIS ordering with default settings is used. Note that the user needs to supply the
METIS library. If METIS is not supplied and this option is requested, the routine
will return immediately with an error.
\item{} {\tt 2} A matching-based elimination ordering is computed using {\tt HSL\_MC80}.
METIS is used on the compressed matrix. This option should only be chosen for indefinite systems.
A scaling is also computed that may be passed to {\tt ssids\_factor}
(see {\tt options\%scaling} below).
\end{description}
The default is {\tt ordering}$=${\tt 1}.
{\bf Restriction:} {\tt ordering}$=${\tt 0}, {\tt 1}, {\tt 2}.

\item[\texttt{nemin}] is a scalar of type  {\tt INTEGER} that controls
node amalgamation. Two neighbours in the elimination tree are merged
if they both involve fewer than {\tt nemin} eliminations.
The default is {\tt nemin$=$8}.
The default is used if {\tt nemin$<$1}.
\end{description}

%%%%%%%%%%%%
\noindent {\bf Options used by {\tt ssids\_factor()}}
\begin{description}
\item[\texttt{scaling}] is a scalar of type default {\tt INTEGER} that controls
the use of scaling. If the optional {\tt scale} argument is supplied to
{\tt ssids\_factor}, the value of this parameter is ignored. The available
options are:
\begin{description}
   \item[\texttt{ $\le$ 0 }] No scaling.
   \item[\texttt{ $=$ 1 }] Generate a scaling using a weighted bipartite matching using
      the Hungarian Algorithm (\texttt{MC64} algorithm).
   \item[\texttt{ $=$ 2 }] Generate a scaling using a weighted bipartite matching using
      the Auction Algorithm (normally lower quality than Hungarian Algorithm, but considerably faster).
   \item[\texttt{ $=$ 3 }] A matching-based ordering has been generated during the
      analyse phase using {\tt options\%ordering $=$ 2}. Use the
      scaling generated as a side-effect of this process. The scaling will be
      the same as that generated with {\tt options\%scaling $=$ 1} if matrix
      values have not changed. This option will generate an error if a
      matching-based ordering was not used.
   \item[\texttt{ $\ge$ 2 }] Generate a scaling by applying the norm-equilibriation
      algorithm of Ruiz.
\end{description}
The default is {\tt scaling}$=${\tt 0}.

\end{description}

%%%%%%%%%%%%
\noindent {\bf Options used by {\tt ssids\_factor()} with
{\tt posdef}$ =${\tt .false.}  ($A$ indefinite)}

\begin{description}
\item[\texttt{action}] is a scalar of type default {\tt LOGICAL}.
If the matrix is found to be singular (has rank less than the number of
non-empty rows), the computation continues after issuing a warning if
{\tt action} has the value {\tt .true.} or
terminates with an error if it has the value {\tt .false.}
The default is {\tt action}$=${\tt .true.}

\item[\texttt{small}] is a scalar of type {\tt REAL}.
Any pivot whose modulus is less than {\tt small} is treated as zero.
The default in the double and double complex versions is
{\tt small}$ = {\tt 10^{-20}}$, and in the single and single complex versions
is {\tt small}$ = {\tt 10^{-12}}$.

\item[\texttt{u}] is a scalar of type {\tt REAL} that holds the relative pivot
tolerance $u$.
The default in the double and double complex versions is {\tt u}$=${\tt 0.01},
and in the single and single complex versions is {\tt u}$=${\tt 0.1}.
Values outside the range $[0,0.5]$ are treated as the closest value in that range.

\end{description}

%%%%%%%%%%%%
\noindent {\bf Options used by {\tt ssids\_factor()} and {\tt ssids\_solve()}}

\begin{description}
\item[\texttt{use\_gpu\_solve}] is a scalar of type {\tt LOGICAL} that specifies
   whether to use the CPU or GPU for the solve. If \texttt{.true.}, the GPU is
   used for the solve, but some more advanced features are not available (see
   the description of the \texttt{job} parameter in Section~\ref{solve}).
\item[\texttt{presolve}] is a scalar of type {\tt INTEGER} that specifies the
   amount of extra work performed during factorization to accelerate the solve.
   It can take the following values:
   \begin{description}
      \item[\texttt{0}] Minimal work is performed during {\tt ssids\_factor()}
         to prepare for the solve.
      \item[\texttt{1}] The explicit inverse of the
         \texttt{nelim}$\times$\texttt{nelim} block in each supernode is
         precalculated during {\tt ssids\_factor()} (where \texttt{nelim} is
         the number of variables eliminated at that supernode). As the matrices
         $L$ and $D$ are altered, the routines {\tt ssids\_enquire\_posdef()},
         {\tt ssids\_enquire\_indef()}, and {\tt ssids\_alter()} cannot be used.
   \end{description}
\end{description}

%%%%%%%%%%% inform type %%%%%%%%%%%

\subsection{The derived data type for holding information}
\label{typeinform}
The derived data type {\tt ssids\_inform}
is used to hold parameters that give information about the progress and needs
of the algorithm. The components of {\tt ssids\_inform}
(in alphabetical order) are:

\begin{description}

\item[\texttt{flag}] is a scalar of type  {\tt INTEGER}
that gives the exit status of the algorithm (details in Section \ref{errors}).

\item[\texttt{matrix\_dup}] is a scalar  of type  {\tt INTEGER}.
On exit from {\tt ssids\_analyse()}
with {\tt check} set to {\tt .true.} or from \\
{\tt ssids\_analyse\_coord()}, it holds the
number of duplicate entries that were found and summed.

\item[\texttt{matrix\_missing\_diag}] is a scalar of type {\tt INTEGER}.
On exit from {\tt ssids\_analyse()} with {\tt check} set to {\tt .true.},
or from {\tt ssids\_analyse\_coord}, it holds the number of diagonal
entries without an explicitly provided value.

\item[\texttt{matrix\_outrange}] is a scalar  of type  {\tt INTEGER}.
On exit from {\tt ssids\_analyse}
with {\tt check} set to {\tt .true.} or from \\
{\tt ssids\_analyse\_coord}, it holds the
number of out-of-range entries that were   found and discarded.

\item[\texttt{matrix\_rank}] is scalar of type  {\tt INTEGER}. On exit from
{\tt ssids\_analyse} and {\tt ssids\_analyse\_coord}, it holds
the structural rank of $A$, if available (otherwise, it is set to {\tt n}).
On exit from
{\tt ssids\_factor}, it holds the computed rank of
the factorized matrix.

\item[\texttt{maxdepth}] is a scalar of type  {\tt INTEGER}. On exit from
{\tt ssids\_analyse}  or {\tt ssids\_analyse\_coord}, it holds the maximum depth of the assembly tree.

\item[\texttt{maxfront}] is a scalar of type  {\tt INTEGER}. On exit from
{\tt ssids\_analyse}  or {\tt ssids\_analyse\_coord}, it holds the maximum front size
in the positive-definite case (or in the indefinite case with
the same pivot sequence). On exit from
{\tt ssids\_factor}, it holds the maximum front size.

\item[\texttt{num\_delay}] is scalar of type  {\tt INTEGER}. On exit from
{\tt ssids\_factor}, it holds the
number of eliminations that were
delayed, that is, the total number of fully-summed
variables that were passed to the father node because
of stability considerations. If a variable is passed
further up the tree, it will be counted again.

\item[\texttt{num\_factor}] is scalar of type {\tt INTEGER(long)}. On exit from
{\tt ssids\_analyse}  or {\tt ssids\_analyse\_coord}, it holds the number of entries that will be in the
factor $L$ in the positive-definite case (or in the indefinite case with
the same pivot sequence). On exit from
{\tt ssids\_factor},
it holds the actual number of entries in the factor
$L$. In the indefinite case, {\tt 2n} entries of ${D}^{-1}$ are
also held.

\item[\texttt{num\_flops}] is scalar of type {\tt INTEGER(long)}. On exit from
{\tt ssids\_analyse}  or {\tt ssids\_analyse\_coord}, it holds the number of
floating-point operations that
will be needed to perform the factorization
in the positive-definite case (or in the indefinite case  with
the same pivot sequence).  On exit from {\tt ssids\_factor}, it holds the
number of floating-point operations performed.

\item[\texttt{num\_neg}] is a scalar  of type  {\tt INTEGER}.
On exit from {\tt ssids\_factor}, it holds
the number of negative eigenvalues of the matrix $D$.


\item[\texttt{num\_sup}] is a scalar of type  {\tt INTEGER}.
On exit from {\tt ssids\_analyse}  or {\tt ssids\_analyse\_coord}, it holds
the number of supernodes in the problem.

\item[\texttt{num\_two}] is scalar of type  {\tt INTEGER}.
On exit from
{\tt ssids\_factor}, it holds the number
of $2 \times 2$ pivots used by the factorization, that is,
the number of $2 \times 2$ blocks in $D$.

\item[\texttt{stat}] is a scalar of type  {\tt INTEGER}.
In the event of an allocation or deallocation error, it
holds the Fortran {\tt stat} parameter if it is available
(and is set to {\tt 0} otherwise).

\item[\texttt{cublas\_error}] is a scalar of type {\tt INTEGER}.
In the event of an error return from the CUBLAS library, it
holds the error code returned (and is {\tt 0} otherwise).

\item[\texttt{cuda\_error}] is a scalar of type {\tt INTEGER}.
In the event of a CUDA error, it holds the error code returned (and is {\tt 0}
otherwise). Note that due to the asynchronous nature of GPU execution, the
reported error may be casued by errors external to {\tt SSIDS}.

\end{description}


%%%%%%%%%%%%%%%%%%%%%% Warning and error messages %%%%%%%%%%%%%%%%%%%%%%%%

\section{Return codes} \label{errors}

A successful return from a subroutine in the package is indicated by
{\tt inform\%flag} having the value zero.
A negative value is associated with an error message that by default will
be output on unit {\tt options\%unit\_error}.

Possible negative values are:

\begin{description}
\item{$-$1} An error has been made in the sequence of calls (this includes
            calling a subroutine after an error that cannot be recovered from).
\item{$-$2} Returned by {\tt ssids\_analyse()} and {\tt ssids\_analyse\_coord()}
            if {\tt n$<$0}. Also returned by {\tt ssids\_analyse\_coord()} if
            {\tt ne$<$1}.
\item{$-$3} Returned by {\tt ssids\_analyse()} if there is an error in
            {\tt ptr(:)}.
\item{$-$4} Returned by {\tt ssids\_analyse()} if all the variable indices in
            one or more columns  are out-of-range. Also returned by
            {\tt ssids\_analyse\_coord()} if all entries are out-of-range.
\item{$-$5} Returned by {\tt ssids\_factor()} if
            {\tt posdef}$=${\tt .false.} and
            {\tt options\%action = .false.} when the matrix is found to be
            singular. The user may reset the matrix values in {\tt val(:)}
            and recall {\tt ssids\_factor()}.
\item{$-$6} Returned by {\tt ssids\_factor()} if
            {\tt posdef}$=${\tt .true.} and the matrix is found to
            be not positive definite. This may be because the Hungarian scaling
            determined that the matrix was structurally singular. The user may
            reset the matrix values in {\tt val(:)} and recall
            {\tt ssids\_factor()}.
\item{$-$7} Returned by {\tt ssids\_factor()} if {\tt ssids\_analyse()} was
            called with {\tt check} set to {\tt .false.} but {\tt ptr(:)}
            and/or {\tt row(:)} is not present.
\item{$-$8} Returned by {\tt ssids\_analyse()}  and
            {\tt ssids\_analyse\_coord()} if {\tt options\%ordering} is
            out-of-range, or {\tt options\%ordering}$=${\tt 0} and the user
            has either failed to provide an elimination order or an error has
            been found in the user-supplied elimination order (as supplied in
            {\tt order(:)}).
\item{$-$9} Returned by {\tt ssids\_analyse()} and
            {\tt ssids\_analyse\_coord()} if {\tt options\%ordering}$=${\tt 2},
            but {\tt val(:)} was not supplied.
\item{$-$10} Returned by {\tt ssids\_solve()} if there is an error in the size
            of array {\tt x(:,:)} (that is, {\tt ldx$<$n} or {\tt nrhs$<$1}).
            The user may reset {\tt ldx} and/or {\tt nrhs} and recall
            {\tt ssids\_solve()}.
\item{$-$11} Returned by {\tt ssids\_solve()} if {\tt job} is out-of-range.
            The user may reset {\tt job} and recall {\tt ssids\_solve()}.
\item{$-$12} Returned by {\tt ssids\_solve()} if the selected combination of
            {\tt posdef{\rm ,} options\%use\_gpu\_solve{\rm ,}
            options\%presolve} and {\tt job} are not compaitble.
\item{$-$13} Returned by {\tt ssids\_enquire\_posdef()} if
            {\tt posdef}$=${\tt .false.} on the last call
            to {\tt ssids\_factor()}.
\item{$-$14} Returned by {\tt ssids\_enquire\_indef()} if
            {\tt posdef}$=${\tt .true.} on the last call to
            {\tt ssids\_factor()}.
\item{$-$15} Returned by {\tt ssids\_factorise} if {\tt options\%scaling$=$3}
            but a matching based ordering was not used during the call to
            {\tt ssids\_analyse} or {\tt ssids\_analyse\_coord} (i.e. was
            called with
            {\tt options\%ordering}$\ne${\tt 2}).
\item{$-$50} Allocation error. If available, the {\tt stat}
            parameter is returned in {\tt inform\%stat}.
            The user may wish to try the more memory conservative codes
            {\tt HSL\_MA86} or {\tt HSL\_MA77}.
\item{$-$51} CUDA error. The CUDA error return value is returned in
            {\tt inform\%cuda\_error}.
\item{$-$52} CUBLAS error. The CUBLAS error return value is returned in
            {\tt inform\%cublas\_error}.
\end{description}
A positive value of {\tt inform\%flag}
is used to warn the user that the input matrix data may be faulty or that
the subroutine cannot guarantee the solution obtained.
Possible values are:
\begin{description}
\item{$+$1} Returned by {\tt ssids\_analyse}
and {\tt ssids\_analyse\_coord} if out-of-range variable
indices found.
Any such entries are ignored  and the computation continues.
{\tt inform\%matrix\_outrange} is set to the number of such entries.

\item{$+$2} Returned by {\tt ssids\_analyse} and {\tt ssids\_analyse\_coord}
if duplicated indices found. Duplicates are recorded and the corresponding
entries are summed. {\tt inform\%matrix\_dup} is set to the number of such entries.

\item{$+$3} Returned by {\tt ssids\_analyse}  and {\tt ssids\_analyse\_coord} if both
out-of-range and duplicated variable indices found.

\item{$+$4} Returned by {\tt ssids\_analyse}  and {\tt ssids\_analyse\_coord}
if  one and more diagonal entries
of $A$ is missing.

\item{$+$5} Returned by {\tt ssids\_analyse}  and {\tt ssids\_analyse\_coord}
if  one and more diagonal entries
of $A$ is missing  and
out-of-range and/or duplicated variable indices have been found.

\item{$+$6} Returned by {\tt ssids\_analyse}  and {\tt ssids\_analyse\_coord} if
$A$ is found be (structurally) singular. This will overwrite any of the above warnings.

\item{$+$7} Returned by {\tt ssids\_factor} if {\tt options\%action} is set
to {\tt .true.} and the matrix is found to be (structurally or numerically)
singular.

\item{$+$8} Returned by {\tt ssids\_factor} if
{\tt options\%ordering}$=${\tt 2} (i.e.
a matching-based ordering was used) but the associated scaling was not (i.e. {\tt options\%scaling}$\ne$
{\tt 3}).

\end{description}

\section{Method} \label{method}


\vspace{0.2in}
\noindent {\tt ssids\_analyse} and {\tt ssids\_analyse\_coord} \\
If {\tt check} is set to {\tt .true.} on the call to {\tt ssids\_analyse}
or if {\tt ssids\_analyse\_coord} is called, the HSL package
{\tt HSL\_MC69} is used to check the matrix data. The cleaned integer matrix data
(duplicates are summed and out-of-range indices discarded) is stored in
{\tt akeep}.
The use of checking is optional on a call to {\tt ssids\_analyse} as it
incurs both time and memory overheads. Some form of checking is recommended
since the behaviour of the other routines in the package
is unpredictable if duplicates and/or out-of-range variable indices are entered.
Calling the \texttt{HSL\_MC69} routine \texttt{mc69\_verify} offers an
alternative that can be used for debugging purposes.

If the user has supplied a pivot order it is checked for errors. Otherwise,
a pivot order is generated using {\tt HSL\_MC68}, or if a matching-based ordering is
requested, {\tt HSL\_MC80}.
The pivot order is used to construct the assembly tree
using {\tt HSL\_MC78}.

On exit, {\tt order} is set so that {\tt order(i)} holds the position
at which variable {\tt i} is eliminated. If a user order was supplied, this
order may differ, but will be equivalent in terms of fill-in to that provided.


If a matching-based ordering is requested and {\tt scale} is present, on exit,
{\tt scale} contains scaling factors computed by {\tt MC64}.
These may be passed unchanged to {\tt ssids\_factor}.

\vspace{0.2in}
\noindent {\tt  ssids\_factor}\\
{\tt ssids\_factor} optionally computes
a scaling and then perform the numerical factorization.
 The user must specify whether or not the matrix is
positive definite. If {\tt posdef} is {\tt .true.}, no pivoting
is performed. As a result the computation will terminate with an error if a
non-positive pivot is encountered.

The factorization uses the assembly tree that was set up by the analyse phase.
If running on a single thread (or if there is insufficient work available to
justify running in parallel), the nodes of the tree are iterated over in a
post-order.

At a node, the contributions from the children relating to those columns
that are fully summed at this node are first assembled. A dense partial
factorization is then performed on these columns. In the positive-definite case,
LAPACK's \texttt{\_potrf} (or \texttt{\_herk} for Hermitian matrices) is used.
In the indefinite case, an algorithm based on the same pivoting algorithm as
\texttt{HSL\_MA64} is used.

The generated element is calculated by first forming the outer product of the
fully summed columns' uneliminated rows. The contributions from the
children are then added, and the stack memory used by the children is freed.
As this involves copying from one stacked contribution to another,
two separate stacks are used to do this.

If a pivot candidate does not pass pivot tests at a given node, it is delayed
to the parent node where additional eliminations may make the pivot feasible.
This results in the generation of additional fill-in and floating-point
operations, and may result in additional memory allocations being required.

In parallel computation, we exploit two levels of parallelism using OpenMP
tasks.
In tree-level parallelism, different subtrees are factorized in independent
tasks. To ensure results are bit-compatible regardless of the number of threads
used, the assembly order of the children is fixed at assembly time.
In node-level parallelism, the operations forming the outer-product in both the
dense factorization kernel and the calculation of the generated element are
broken into multiple tasks. Bit-compatibility is ensured in this case by using
a data-parallel approach so each individual sum is effectively calculated in
serial.

\vspace{0.2in}
\noindent {\tt ssids\_solve}\\
Having checked the user's data, {\tt ssids\_solve} performs a forward
substitution followed by a combined diagonal solve and back substitution
(unless only one of these is requested).

In a supernodal solve updates are done directly into the right-hand side vector
and do not readily admit bit-compatible parallelism in the forward substitution.
In the multifrontal solve updates are passed up the tree utilising a stack. This
allows parallelism to be implemented but can be slower than the supernodal
solve on small problems.
Regardless of whether a supernodal or multifrontal solve is chosen the same
backwards solve is used that works directly on the right-hand side vectors. Due
to the differing data dependencies from the forward substitution a
bit-compatible parallel solve is possible.

The matrix factor must be accessed once for the
forward substitution and once for the back substitution. This is
independent of the number of right-hand sides so that solving for
several right-hand sides at once is significantly faster
than repeatedly solving for a single right-hand side.

\subsection*{References}
[1] J.D. Hogg and J.A. Scott. (2011).
{\tt HSL\_MA97}: a bit-compatible multifrontal code for sparse symmetric
systems.
RAL Technical Report. RAL-TR-2011-024.



%%%%%%%%%%%%%%%%%%%%%% EXAMPLE %%%%%%%%%%%%%%%%%%%%%%%%

\section{Examples} \label{examples}

\subsection{First example: sparse column entry}
Suppose we wish to factorize the matrix
\[ A = \left(
\begin{array}{ccccc}
2. & 1. \\
1. & 4. & 1. & & 1. \\
 & 1. & 3. & 2. \\
& & 2. & 0. &  \\
& 1. & & & 2.
\end{array}
\right)
\]
and then solve for the right-hand side
\[ B = \left(
\begin{array}{c}
4. \\
12. \\
10. \\
4. \\
4.
\end{array}
\right).
\]

\noindent
The following code may be used.
\begin{verbatim}
! Simple code to illustrate use of spral_ssids
program ssidsds
   use spral_ssids
   implicit none

   ! Derived types
   type (ssids_akeep)   :: akeep
   type (ssids_fkeep)   :: fkeep
   type (ssids_options) :: options
   type (ssids_inform)    :: info

   ! Parameters
   integer, parameter :: wp = kind(0.0d0)

   integer, dimension (:),  allocatable :: ptr
   integer, dimension (:),  allocatable :: piv_order
   integer, dimension (:),  allocatable :: row
   real(wp), dimension (:), allocatable :: val
   real(wp), dimension (:), allocatable :: x
   real(wp), dimension (:,:), allocatable :: d

   integer :: matrix_type,n,ne
   logical :: check

   ! Read in the order n of the matrix and number of entries in lower triangle
   read (*,*) n,ne

   ! Allocate arrays for matrix data and arrays for ssids
   allocate (ptr(n+1),row(ne),val(ne))
   allocate (x(n),d(2,n))

   read (*,*) ptr(1:n+1)
   read (*,*) row(1:ne)
   read (*,*) val(1:ne)

   ! Perform analyse and factorise with data checking
   check = .true.
   call ssids_analyse(check,n,ptr,row,akeep,options,inform)
   if (inform%flag < 0) go to 100
   matrix_type = 4 ! Real, symmetric indefinite
   call ssids_factor(matrix_type,val,akeep,fkeep,options,inform)
   if (inform%flag < 0) go to 100

   ! Read in the right-hand side and copy into resid.
   read (*,*) x(1:n)

   ! Solve
   call ssids_solve(x,akeep,fkeep,options,inform)
   if (inform%flag < 0) go to 100
   write (*,'(/a,/,(3es18.10))') ' The computed solution is:', x(1:n)

   ! Determine the pivot order used
   allocate (piv_order(1:n))
   call ssids_enquire_indef(piv_order, d, akeep, fkeep, options, inform)
   write (6,*) 'piv_order', piv_order(1:n)

   100 continue
   call ssids_finalise(akeep, fkeep)

end program ssidsds
\end{verbatim}
\noindent
with the following data:
\begin{verbatim}
  5  8
  1  3  6  8  8  9
  1  2  2  5  3  4  3  5
  2. 1. 4. 1. 1. 2. 3. 2.
  4. 12. 10. 4. 4.
\end{verbatim}
\noindent
This produces the following output:
\begin{verbatim}
 The computed solution is:
     1.000     2.000     2.000     1.000     1.000
\end{verbatim}

\subsection{Second example: coordinate entry, refactorization}
{\bf FIXME: Remove factor\_solve}
Suppose we wish to factorize the matrix
\[ A = \left(
\begin{array}{ccccc}
1. & -3. & & 1. \\
-3. & -5. & 6. & & 4.\\
& 6. & & 2. \\
1. & & 2. & 3. \\
& 4. & & & 1.
\end{array}
\right)
\]
and then solve for the right-hand sides
\[ B = \left(
\begin{array}{cc}
-1. & -5.\\
25. & -40. \\
20. & 8. \\
19. & -8. \\
13. & -1.
\end{array}
\right)
\].
Suppose we then wish to solve the following system with the same pattern in a
single call:
\[ \left(
\begin{array}{ccccc}
2. & 1. & & 7. \\
1. & 1. & 8. & & 2.\\
& 8. & & 1. \\
7. & & 1. & 8. \\
& 2. & & & 8.
\end{array}
\right) \mathbf{x} = \left(
\begin{array}{c}
8. \\
89. \\
40. \\
37. \\
42.
\end{array}
\right)
\]

\noindent
The following code may be used.
\begin{verbatim}
! Simple code to illustrate use of spral_ssids
program ssidsds1
   use spral_ssids
   implicit none

   ! Derived types
   type (ssids_akeep)   :: akeep
   type (ssids_fkeep)   :: fkeep
   type (ssids_options) :: options
   type (ssids_inform)    :: info

   ! Parameters
   integer, parameter :: wp = kind(0.0d0)

   integer, dimension (:),  allocatable :: row
   integer, dimension (:),  allocatable :: col
   real(wp), dimension (:), allocatable :: val
   real(wp), dimension (:,:), allocatable :: x

   integer :: matrix_type,n,ne,cuda_error

   ! Read in the order n of the matrix and number of entries in lower triangle
   read (*,*) n,ne

   ! Allocate arrays for matrix data and arrays for ssids
   allocate (row(ne),col(ne),val(ne))
   allocate (x(n,2))

   read (*,*) row(1:ne)
   read (*,*) col(1:ne)
   read (*,*) val(1:ne)

   ! Perform analyse and factorise with coordinate input
   call ssids_analyse_coord(n,ne,row,col,akeep,options,inform)
   if (inform%flag < 0) go to 100
   matrix_type = 4 ! Real, symmetric indefinite
   call ssids_factor(matrix_type,val,akeep,fkeep,options,inform)
   if (inform%flag < 0) go to 100

   ! Read in the right-hand side
   read (*,*) x(1:n,1:2)

   ! Solve
   call ssids_solve(2,x,n,akeep,fkeep,options,inform)
   if (inform%flag < 0) go to 100
   write (*,'(/a,/,(3es18.10))') ' The computed solution is:', x(1:n,1)
   write (*,'(3es18.10)') x(1:n,2)

   ! Read values of second matrix with same pattern
   read (*,*) val(1:ne)

   ! Read another right hand side
   read (*,*) x(1:n,1)

   ! Perform combined factor and solve
   call ssids_factor_solve(matrix_type,val,x(1:n,1),akeep,fkeep,options,inform)
   write (*,'(/a,/,(3es18.10))') ' Next solution is:', x(1:n,1)

   100 continue
   call ssids_finalise(akeep, fkeep, cuda_error)

end program ssidsds1
\end{verbatim}
\noindent
with the following data:
\begin{verbatim}
5 9
1   2   1   2   3   5   4   4   5
1   1   4   2   2   2   4   3   5
1. -3.  1. -5.  6.  4.  3.  2.  1.
-1.  25.  20.  19.  13.
-5. -40.   8.  -8.  -1.
2.  1.  7.  1.  8.  2.  8.  1.  8.
16.5 89.0 40.5 41.0 42.0
\end{verbatim}
\noindent
This produces the following output:
\begin{verbatim}

 Warning from ssids_analyse_coord. Warning flag =   4
 one or more diagonal entries is missing

 The computed solution is:
  1.0000000000E+00  2.0000000000E+00  3.0000000000E+00
  4.0000000000E+00  5.0000000000E+00
 -3.0000000000E+00  1.0000000000E+00 -4.0000000000E+00
  1.0000000000E+00 -5.0000000000E+00

 Next solution is:
  4.0000000000E+00  5.0000000000E+00  9.0000000000E+00
  5.0000000000E-01  4.0000000000E+00
\end{verbatim}
Note that the warning is entirely innocous and is merely due to the absence of
a non-zero in the diagonal $(3,3)$ position.

\begin{funders}
   \funder{epsrc}{Funded by EPSRC grant EP/J010553/1}
\end{funders}

\end{document}
