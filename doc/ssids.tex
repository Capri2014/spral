\documentclass{spral}

\newcommand{\packagename}{SSIDS}
\newcommand{\version}{1.0.0}
\newcommand{\versiondate}{7 March 2014}
\newcommand{\purpose}{
This package solves one or more sets of $n\times n$
sparse {\bf symmetric} equations  ${AX = B}$ using a multifrontal method on an
\textbf{NVIDIA GPU}.
The package covers the following cases:
\begin{enumerate}
\item $A$ is {\bf positive definite}.
SSIDS computes the {\bf sparse Cholesky factorization}
$$
   A =  PL(PL)^T
$$
where $P$ is a permutation matrix and $L$ is lower triangular.
\item $A$ is {\bf indefinite}.
SSIDS computes the sparse factorization
$$
   A =  PLD(PL)^T
$$
where $P$ is a permutation matrix, $L$ is unit lower triangular,
and $D$ is block diagonal with blocks of size $1 \times 1 $
and $2 \times 2$.
\end{enumerate}

SSIDS is designed to produce \textbf{bit-compatible solutions on
any number of threads} (see Sections~\ref{openmp} and \ref{bitcompat}).
That is to say, regardless of running in serial or parallel,
it will always get the same answer (on the same machine with the same binary).

An option exists to scale the matrix. In this case, the factorization of
the scaled matrix  $ {\overline{A} = S A S}$ is computed,
where ${S}$ is a diagonal scaling matrix.
}


\begin{document}

\title{Sparse Symmetric Indefinite Direct Solver}
\author{
   Jonathan Hogg (STFC Rutherford Appleton Laboratory) \\
   Evgueni Ovtchinnikov (STFC Rutherford Appleton Laboratory) \\
   Jennifer Scott (STFC Rutherford Appleton Laboratory)
}
\pkglang{Fortran}
\maketitle
\thispagestyle{firststyle}

\section*{Major version history}
\begin{description}
\item[2014-03-07 Version 1.0.0] Initial release
\end{description}

%%%%%%%%%%%%%%%%%%%%%% HOW TO USE %%%%%%%%%%%%%%%%%%%%%%%%

\section{How to use this package}

\subsection{Calling sequences}

Access to the package requires a {\tt USE} statement \\ \\
\indent\hspace{8mm}{\tt use spral\_ssids} \\

\medskip

\noindent
The following procedures are available to the user:
\begin{itemize}
\item {\tt ssids\_analyse} accepts the matrix data in compressed
sparse column format and optionally checks it for duplicates and  out-of-range entries.
The user may supply an elimination order; otherwise
one is generated. Using this elimination order,
{\tt ssids\_analyse}  analyses the sparsity pattern of
the matrix and prepares the data structures for the factorization.

 \item {\tt ssids\_analyse\_coord} is an alternative to
{\tt ssids\_analyse} that may be used if the user has
the matrix data held in coordinate
format. Again, the user may supply an elimination order; otherwise
one is generated. {\tt ssids\_analyse\_coord}
checks the matrix data  for duplicates and  out-of-range entries,
stores
it in compressed sparse column format and then proceeds
in the same way as {\tt ssids\_analyse}.

\item {\tt ssids\_factor} uses the data structures
set up by {\tt ssids\_analyse} to compute a sparse
factorization. More than one call to  {\tt ssids\_factor}
may follow a call to {\tt ssids\_analyse} (allowing more than
one matrix with the same sparsity pattern but different
numerical values to be factorized without multiple calls to
{\tt ssids\_analyse}).
An option exists to scale the matrix.

\item {\tt ssids\_solve} uses the computed factors generated
by  {\tt ssids\_factor}
to solve systems ${AX= B}$
for one or more right-hand sides $B$.
Multiple calls to {\tt ssids\_solve} may follow a call to
{\tt ssids\_factor}.
An option is available to perform a partial solution.

\item {\tt ssids\_finalise} should be called after all other calls
are complete for a problem (including after an error
return that does not allow the computation
to continue). It frees memory referenced by components of
the derived data types.
\end{itemize}

\noindent
In addition, the following routines may be called:
\begin{itemize}
\item {\tt ssids\_free} may be called to free memory associated with {\tt akeep}
or {\tt fkeep} when a call to {\tt ssids\_finalise} is not appropriate (for
example, if a further factorization is to be performed for a matrix with the
same sparsity pattern).
\item {\tt ssids\_enquire\_posdef} may be called
in the  positive-definite case to obtain the pivots used.
\item {\tt ssids\_enquire\_indef} may be called
in the indefinite case to obtain the pivot sequence used by the factorization
and the entries of  ${D}^{-1}$.
\item {\tt ssids\_alter} may be called in the indefinite case to alter
the entries of ${D}^{-1}$.
Note that this means that  $PLD(PL)^T$ is no longer
a factorization of $A$.

\end{itemize}

%%%%%%%%%%%%%%%%%%%%%% OpenMP usage %%%%%%%%%%%%%%%%%%%%%%%%

\subsection{OpenMP} \label{openmp}
OpenMP is used by SSIDS to provide parallelism for
shared memory environments on the host.  To run in parallel, OpenMP must be
enabled at
compilation time by using the correct compiler flag (usually some variant of
{\tt -openmp}). The number of threads may be controlled at runtime
by setting the environment variable {\tt OMP\_NUM\_THREADS}.

\subsection{CUDA} \label{CUDA}
CUDA is used by SSIDS to implement its GPU functionality. You must tell the
configure script how to find {\tt nvcc} in order to compile, and you must have
a graphics card of at least CUDA capability 2.0 in order to run.

\subsection{Achieving bit-compatibility} \label{bitcompat}
Care has been taken to allow bit-compatibility to be achieved using this solver.

%%%%%%%%%%%%%%%%%%%%%% derived types %%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Derived types} \label{derived types}

For each problem, the user must employ the derived types defined by the
module to declare scalars of the types
{\tt ssids\_control}, {\tt ssids\_info}, {\tt ssids\_akeep}, and {\tt ssids\_fkeep}.
The following pseudo-code illustrates this.
\begin{verbatim}
      use spral_ssids
      ...
      type (ssids_control) :: control
      type (ssids_info) :: info
      type (ssids_akeep) :: akeep
      type (ssids_fkeep) :: fkeep
      ...
\end{verbatim}
The components of {\tt ssids\_control} and {\tt ssids\_info} are explained
in Sections~\ref{typecontrol} and \ref{typeinform}.
The components of {\tt ssids\_akeep} and {\tt ssids\_fkeep} are used to pass
data between the subroutines of the package and must not be altered by the user.

\subsection{METIS}
The package uses the METIS graph partitioning library available from
the University of Minnesota website. Both versions 4 and 5 are supported.


%%%%%%%%%%%%%%%%%%%%%% argument lists %%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Argument lists}

\subsubsection{Optional arguments}\label{Optional arguments}

We use square brackets {\tt [ ]} to indicate {\it optional} arguments.
In each
call, optional arguments follow the argument {\tt info}.  Since we
reserve the right to add additional optional arguments in future
releases of the code, {\bf we strongly recommend that all optional
arguments be called by keyword, not by position}.

\subsubsection{Integer, real and package types}\label{Integer kinds}

{\tt INTEGER} denotes default {\tt INTEGER} and
{\tt INTEGER(long)} denotes {\tt INTEGER(kind=selected\_int\_kind(18))}.

\noindent
{\tt REAL} denotes default real if the single precision version, and double
precision real if the double precision is being used.
We use the term {\bf package type} to mean
default real if the single precision version is being used,
double precision real for the double precision version.


%%%%%%%%% analyse subroutine %%%%%%

\subsubsection{To analyse the sparsity pattern and prepare
for the factorization: CSC format}\label{analyse}


If the matrix data is held in compressed sparse
column (CSC) format, the analyse phase optionally checks
the user's data for out-of-range and duplicate entries.
Only the lower triangular part of the matrix $A$ is required;
any entries in the upper triangular part are regarded as  out of range.
Entries on the diagonal that are zero do not need to be entered explicitly.
If checking is carried out, the cleaned matrix data (duplicates are summed
during the factorization and out-of-range entries discarded) is
held within the {\tt ssids\_akeep} derived
data type  and the user data {\tt ptr} and {\tt row}
is not required by any of the remaining subroutines in the package.
If the data is not checked, {\tt ptr} and {\tt row}
must be passed unchanged to the factorization routines.
Note that in this case, the
presence of out-of-range or duplicates
may cause this routine or any of the other routines
in the package to fail in an unpredictable way.

\noindent
A call of the following form should be made:
\begin{verbatim}
     call ssids_analyse(check,n,ptr,row,akeep,control,info[,order,val])
\end{verbatim}

\vspace*{-3mm}
\begin{description}

\item[\texttt{check}] is an \intentin\ scalar of
type  {\tt LOGICAL}. If set to {\tt .true.} the matrix
data is checked for errors and the cleaned matrix
(duplicates are summed and out-of-range entries
discarded) is stored in {\tt akeep}.
Otherwise, no checking of the matrix data is carried out
and {\tt ptr} and {\tt row} must be passed unchanged to the factorization routines.

\item[\texttt{n}] is an \intentin\ scalar of
type  {\tt INTEGER} that must hold the order of $A$.
{\bf Restriction:} {\tt n$\geq$0}.

\item[\texttt{ptr}] is an \intentin\ rank-1 array of type  {\tt INTEGER} and
size {\tt n+1}. {\tt ptr(j)}  must be set by the user
so that {\tt ptr(j)} is the position in {\tt row}
of the first entry in column {\tt j} and {\tt ptr(n+1)} must be set to one
more than the number of matrix entries being input by the user.

\item[\texttt{row}] is an \intentin\ rank-1 array of
type  {\tt INTEGER}. It must hold the row indices of the entries
of the lower triangular part of $A$ with the row indices for
the entries in column 1
preceding those for column 2, and so on (within each column, the row indices
may be in arbitrary order). If {\tt check} is set to {\tt .false.}, {\tt row}
must contain no duplicates or out-of-range entries (including
no entries in the upper triangular part).

\item[\texttt{akeep}]  is an \intentout\ scalar of type
{\tt ssids\_akeep}. It is used to hold data about the problem being
solved and must be passed unchanged to the other subroutines.

\item[\texttt{control}] is an \intentin\ scalar of type {\tt ssids\_control}
(see Section~\ref{typecontrol}).

\item[\texttt{info}] is an \intentout\ scalar of type
{\tt ssids\_info}. Its components provide information about the execution
of the subroutine, as explained in Section~\ref{typeinform}.

\item[\texttt{order}] is an optional \intentinout\ rank-1 array of type {\tt INTEGER}
and size  {\tt n}. If
{\tt control\%ordering}$=${\tt 0},  {\tt order} must be present and {\tt order(i)} must
hold the  position of variable $i$  in the elimination order.
If the user wants to suggest a 2$\times$2 pivot involving variables
$i$ and $j$, {\tt order(j)} should be set to {\tt order(i)}$+${\tt 1}.
If {\tt control\%ordering}$\ge${\tt 1}, {\tt order} need not be set on
entry and the elimination order is computed within the analyse phase.
On exit, {\tt order} contains the elimination order that {\tt ssids\_factor}
will be given
(it is passed to these routines as part of {\tt akeep});
this order may give slightly
more fill-in than the user-supplied order and, in the indefinite case,
may be modified by {\tt ssids\_factor}
to maintain numerical stability. 

\item[\texttt{val}] is an optional \intentin\ rank-1 array of package type.
If present,  {\tt val(k)} must hold
the value of the entry in {\tt row(k)}. {\tt val} must be present
if a matching-based elimination ordering is required ({\tt control\%ordering$=$2}).

\end{description}

%%%%%%%%% analyse subroutine coo%%%%%%

\subsubsection{To analyse the sparsity pattern and prepare
for the factorization: coordinate format}

If the matrix data is held in coordinate format, entries in the upper
and/or lower triangular part of $A$ may be input using
a call of the following form:
\begin{verbatim}
     call ssids_analyse_coord(n,ne,row,col,akeep,control,info[,order,val])
\end{verbatim}

\vspace*{-3mm}
\begin{description}

\item{} {\tt n} is an \intentin\ scalar of
type  {\tt INTEGER} that must hold the order of $A$.
{\bf Restriction:} {\tt n$\geq$0}.

\item{} {\tt ne} is an \intentin\ scalar of
type  {\tt INTEGER} that must hold the number of matrix entries being input
by the user.
{\bf Restriction:} {\tt ne$\geq$1}.

\item{} {\tt row} and {\tt col} are \intentin\ rank-1 arrays of
type  {\tt INTEGER} and size {\tt ne}.
Each diagonal entry $a_{ii}$ of $A$ must be represented by
{\tt row(k)}$=${\tt i} and {\tt col(k)}$=${\tt i} and each  pair of  off-diagonal entries
 $a_{ij}$ and $a_{ji}$ must be represented by {\tt row(k)}$=${\tt i} and
 {\tt col(k)}$=${\tt j} or by {\tt row(k)}$=${\tt j} and {\tt col(k)}$=${\tt i}.
Duplicated entries are summed and out-of-range entries are discarded.

\item[\texttt{akeep{\rm ,} control{\rm ,} info{\rm ,} order{\rm :}}] see Section~\ref{analyse}.

\item[\texttt{val}] is an optional \intentin\ rank-1 array of package type.
If present,  {\tt val(k)} must hold
the value of the entry in {\tt row(k)} and {\tt col(k)}. {\tt val} must be present
if a matching-based elimination ordering is required ({\tt control\%ordering$=$2}).

\end{description}

%%%%%%%%% factorize subroutine %%%%%%
\subsubsection{To factorize the matrix}\label{factorize}

To factorize the matrix, a call of the following form should be made:

\begin{verbatim}
     call ssids_factor(posdef,val,akeep,fkeep,control,info[,scale,ptr,row])
\end{verbatim}
\vspace*{-3mm}
\begin{description}
\item[\texttt{posdef}] is an \intentin\ scalar of type {\tt LOGICAL} that
must be set to {\tt .true.} if the matrix is positive-definite, and
{\tt .false.} if it is indefinite.

\item[\texttt{val}] is an \intentin\ rank-1 array of package type.
If {\tt ssids\_analyse} was called,  {\tt val(k)} must hold
the value of the entry in {\tt row(k)}.
Otherwise, if  {\tt ssids\_analyse\_coord} was called,  {\tt val(k)}
must hold the value of the entry in {\tt row(k)} and {\tt col(k)}.

\item[\texttt{akeep}]  is an \intentin\ scalar of type
{\tt ssids\_akeep} that must be unchanged since the
call to {\tt ssids\_analyse} or {\tt ssids\_analyse\_coord}.

\item[\texttt{control{\rm ,} info{\rm :}}] see
Section~\ref{analyse}.

\item[\texttt{fkeep}]  is an \intentinout\ scalar of type
{\tt ssids\_fkeep}. It is used to hold data about the problem being
solved and must be passed unchanged to the other subroutines.

\item[\texttt{scale}] is an optional \intentinout\ rank-1 array of type {\tt REAL}
and size  {\tt n}. If {\tt scale} is present, it must contain  the diagonal
entries of the scaling matrix ${S}$ and is unchanged on exit.

\item[\texttt{ptr}] and {\tt row} are optional \intentin\ rank-1 arrays of
type  {\tt INTEGER}. They are only accessed if
{\tt ssids\_analyse} was called
with {\tt check} set to {\tt .false.}.
In this case, they must both be present and  must be unchanged since that call.

\end{description}

%%%%%%%%% solve subroutine %%%%%%
\subsubsection{To solve linear systems using the computed factors}
\label{solve}

After the call to {\tt ssids\_factor},
one or more calls of the following form may be made to solve
${AX = B}$. Partial solutions may be
performed by appropriately setting the optional
parameter {\tt job}.
For a single right-hand side,
\begin{verbatim}
     call ssids_solve(x1,akeep,fkeep,control,info[,job])
\end{verbatim}
or, for more than one right-hand side,
\begin{verbatim}
     call ssids_solve(nrhs,x,ldx,akeep,fkeep,control,info[,job])
\end{verbatim}

\vspace*{-3mm}
\begin{description}
\item[\texttt{x1{\rm ,} nrhs{\rm ,} x{\rm ,} ldx{\rm ,} akeep{\rm :}}]
see Section~\ref{factorize}.

\item[\texttt{fkeep}]  is an \intentin\ scalar of type
{\tt ssids\_fkeep} that must be unchanged since the
last call to {\tt ssids\_factor}.

\item[\texttt{control{\rm ,} info{\rm :}}] see Section~\ref{analyse}.


\item[\texttt{job}] is an optional  \intentin\ scalar of
type  {\tt INTEGER}. If absent, ${AX = B}$ is solved.
In the positive-definite case, the Cholesky factorization
that has been computed may be expressed in the form
\[ {SAS} = ({PL})({PL})^T \]
where $P$ is a permutation matrix and $L$ is lower triangular.
In the indefinite case, the factorization
that has been computed may be expressed in the form
\[ {S AS} = ({PL}){D}({PL})^T \]
where $P$ is a permutation matrix, $L$ is unit lower triangular,
and $D$ is block diagonal with blocks of order 1 and 2.
$S$ is a diagonal scaling matrix ($S$ is equal to the identity,
if \texttt{control\%scaling=0} and
{\tt scale} is not present on the last call to {\tt ssids\_factor}).
A partial solution may be computed by setting {\tt job} to have
one of the following values:
\begin{description}
\item[\texttt{1}] for solving ${PLX} = {SB}$
\item[\texttt{2}] for solving ${DX} = {B}$ (indefinite case only)
\item[\texttt{3}] for solving $({PL})^T{S^{-1}X} = {B}$
\item[\texttt{4}] for solving $D({PL})^T{S^{-1}X} = {B}$ (indefinite case only)
\end{description}
{\bf Restriction:} {\tt job = 1,2,3,4}.

\end{description}

%%%%%%% termination subroutine %%%%%%

\subsubsection{The finalisation and free subroutines}
Once all other calls are complete for a problem or after an error
return that does not allow the computation to continue,
a call should be made to free memory allocated by SSIDS and
associated with the structures {\tt akeep} and/or {\tt fkeep} using calls to
\texttt{ssids\_free}.

\noindent
The \texttt{ssids\_finalise} call is provided as a convenient shortcut for
freeing memory associated with both \texttt{akeep} and \texttt{fkeep}.

\begin{verbatim}
     call ssids_free(akeep)
     call ssids_free(fkeep,cuda_error)
     call ssids_finalise(akeep,fkeep,cuda_error)
\end{verbatim}

\vspace*{-3mm}
\begin{description}

\item[\texttt{akeep}] is an \intentinout\ scalar  of type {\tt ssids\_akeep}
that must be passed unchanged.
On exit, allocatable components will have been deallocated.

\item[\texttt{fkeep}] is an \intentinout\ scalar  of type {\tt ssids\_fkeep}
that must be passed unchanged.
On exit, allocatable components will have been deallocated.

\item[\texttt{cuda\_error}] is an \intentout\ scalar of type default integer.
On exit, a non-zero value gives a CUDA error code. This may indicate either
a failure to deallocate GPU memory, or a pre-existing CUDA error condition.
Such a pre-existing error condition may have resulted from either user or
\texttt{SSIDS} code.


\end{description}

%%%%%%% enquire subroutine %%%%%%

\subsubsection{To obtain information on the factorization (positive-definite case)}

After a successful call to {\tt ssids\_factor}
with {\tt posdef}$=${\tt .true.} and prior to
a call to {\tt ssids\_free} or {\tt ssids\_finalise}, information on the
pivots may be obtained using a call of the form
\begin{verbatim}
     call ssids_enquire_posdef(akeep,fkeep,control,info,d)
\end{verbatim}

\vspace*{-3mm}
\begin{description}


\item[\texttt{akeep{\rm ,} fkeep{\rm :}}] see Section~\ref{solve}.

\item[\texttt{control{\rm ,} info{\rm :}}] see Section~\ref{analyse}.

\item[\texttt{d}] is an  \intentout\ rank-1 array of type {\tt  REAL} and
size {\tt n}.
The {\tt i}-th pivot will be placed in {\tt d(i)},
{\tt i = 1,2,...,n}.

\end{description}
%%%%%%% enquire subroutine %%%%%%

\subsubsection{To obtain information on the factorization (indefinite case)}

After a successful call to {\tt ssids\_factor}
with {\tt posdef}$=${\tt .false.} and prior to
a call to {\tt ssids\_free} or {\tt ssids\_finalise}, information on the
pivot sequence and the matrix ${D}^{-1}$
may be obtained using a call of the form
\begin{verbatim}
     call ssids_enquire_indef(akeep,fkeep,control,info[,piv_order,d])
\end{verbatim}

\vspace*{-3mm}
\begin{description}

\item[\texttt{akeep{\rm ,} fkeep{\rm :}}]  see Section~\ref{solve}.

\item[\texttt{control{\rm ,} info{\rm :}}]  see Section~\ref{analyse}.

\item[\texttt{piv\_order}] is an optional \intentout\ rank-1 array of type {\tt INTEGER}
and size {\tt n}. If present, then if {\tt i} is used to
index a variable,
its position in the pivot sequence will
be placed in {\tt piv\_order(i)}, with its sign negative if it is
part of a $2 \times 2$ pivot.

\item[\texttt{d}] is an optional \intentout\ rank-2 array of package type with
extents {\tt 2} and {\tt n}.
If present, the diagonal entries of ${D}^{-1}$ will be placed
in {\tt d(1,i)}, {\tt i = 1,2,\ldots,n},
the off-diagonal entries  of ${D}^{-1}$ will be placed in
{\tt d(2,i)}, {\tt i = 1,2,\ldots,n-1}, and
{\tt d(2,n)} will be set to zero.

\end{description}


%%%%%%% alter subroutine %%%%%%

\subsubsection{To alter ${\bf D}^{-1}$}

After a successful call to {\tt ssids\_factor} with
{\tt posdef}$=${\tt .false.} and prior to
a call to {\tt ssids\_free} or {\tt ssids\_finalise},
the matrix ${D}^{-1}$ may be altered  using a call of the form
\begin{verbatim}
     call ssids_alter(d,akeep,fkeep,control,info)
\end{verbatim}

\vspace*{-3mm}
\begin{description}

\item[\texttt{d}] is an \intentin\ rank-2  array of package type with
extents {\tt 2}  and {\tt n}. The diagonal entries
of ${D}^{-1}$ will be altered to {\tt d(1,i)}, {\tt i = 1,2,...,n},
and the off-diagonal entries will be altered to
{\tt d(2,i)}, {\tt i = 1,2,...,n-1} (and $PLD(PL)^T$ will no longer be
a factorization of $A$).

\item[\texttt{akeep{\rm ,} fkeep{\rm :}}]  see Section~\ref{solve}.

\item[\texttt{control{\rm ,} info{\rm :}}]  see Section~\ref{analyse}.
\end{description}

%%%%%%%%%%% control type %%%%%%%%%%%

\subsection{The derived types}
\subsubsection{The derived data type for holding control parameters}
\label{typecontrol}

The derived data type {\tt ssids\_control}
is used to hold controlling data. The components, which are automatically
given default values in the definition of the type, are: \\

%%%%%%%%%%%%
\noindent {\bf Printing controls}

\begin{description}

\item[\texttt{print\_level}] is a scalar of type  {\tt INTEGER}
that is used to controls the level of  printing. The different levels are:
\begin{description}
\item{\tt $<$ 0 } No printing.
\item{\tt = 0 } Error and warning messages only.
\item{\tt = 1 } As 0, plus basic diagnostic printing.
\item{\tt $>$ 1 } As 1, plus some additional diagnostic printing.
\end{description}
The default is {\tt print\_level$=$\tt 0}.

\item[\texttt{unit\_diagnostics}] is a scalar  of type
{\tt INTEGER} that holds the
unit number for diagnostic printing. Printing is suppressed if
{\tt unit\_diagnostics$<0$}.
The default is {\tt unit\_diagnostics$=$6}.

\item[\texttt{unit\_error}] is a scalar of type  {\tt INTEGER} that holds the
unit number for error messages.
Printing of error messages
is suppressed if {\tt unit\_error$<$0}.
The default is {\tt unit\_error$=$6}.

\item[\texttt{unit\_warning}] is a scalar  of type  {\tt INTEGER} that holds the
unit number for warning messages.
Printing of warning messages is suppressed if {\tt unit\_warning$<$0}.
The default is {\tt unit\_warning$=$6}.

\end{description}



%%%%%%%%%%%%
\noindent {\bf Controls used by {\tt ssids\_analyse} and
{\tt ssids\_analyse\_coord}}

\begin{description}

\item[\texttt{ordering}] is a scalar of
type  {\tt INTEGER}. If set to {\tt 0}, the user
must supply an elimination order in {\tt order}; otherwise
an elimination order will be computed by {\tt ssids\_analyse}
or {\tt ssids\_analyse\_coord}.
The options are:
\begin{description}
\item{} {\tt 0} User-supplied ordering is used.
\item{} {\tt 1} METIS ordering with default settings is used. Note that the user needs to supply the
METIS library. If METIS is not supplied and this option is requested, the routine
will return immediately with an error.
\item{} {\tt 2} A matching-based elimination ordering is computed using {\tt HSL\_MC80}.
METIS is used on the compressed matrix. This option should only be chosen for indefinite systems.
A scaling is also computed that may be passed to {\tt ssids\_factor}
(see {\tt control\%scaling} below).
\end{description}
The default is {\tt ordering}$=${\tt 1}.
{\bf Restriction:} {\tt ordering}$=${\tt 0}, {\tt 1}, {\tt 2}.

\item[\texttt{nemin}] is a scalar of type  {\tt INTEGER} that controls
node amalgamation. Two neighbours in the elimination tree are merged
if they both involve fewer than {\tt nemin} eliminations.
The default is {\tt nemin$=$8}.
The default is used if {\tt nemin$<$1}.
\end{description}

%%%%%%%%%%%%
\noindent {\bf Controls used by {\tt ssids\_factor}}
\begin{description}
\item[\texttt{action}] is a scalar of type default {\tt INTEGER} that controls
the use of scaling. If the optional {\tt scale} argument is supplied to
{\tt ssids\_factor}, the value of this parameter is ignored. The available
options are:
\begin{description}
   \item[\texttt{ $\le$ 0 }] No scaling.
   \item[\texttt{ $=$ 1 }] Generate a scaling using a weighted bipartite matching using
      the Hungarian Algorithm (\texttt{MC64} algorithm).
   \item[\texttt{ $=$ 1 }] Generate a scaling using a weighted bipartite matching using
      the Auction Algorithm (normally lower quality than Hungarian Algorithm, but considerably faster).
   \item[\texttt{ $=$ 3 }] A matching-based ordering has been generated during the
      analyse phase using {\tt control\%ordering $=$ 2}. Use the
      scaling generated as a side-effect of this process. The scaling will be
      the same as that generated with {\tt control\%scaling $=$ 1} if matrix
      values have not changed. This option will generate an error if a
      matching-based ordering was not used.
   \item[\texttt{ $\ge$ 2 }] Generate a scaling by applying the norm-equilibriation
      algorithm of Ruiz.
\end{description}
The default is {\tt scaling}$=${\tt 0}.

\end{description}

%%%%%%%%%%%%
\noindent {\bf Controls used by {\tt ssids\_factor} with
{\tt posdef}$ =${\tt .false.}  ($A$ indefinite)}

\begin{description}
\item[\texttt{action}] is a scalar of type default {\tt LOGICAL}.
If the matrix is found to be singular (has rank less than the number of
non-empty rows), the computation continues after issuing a warning if
{\tt action} has the value {\tt .true.} or
terminates with an error if it has the value {\tt .false.}
The default is {\tt action}$=${\tt .true.}

\item[\texttt{multiplier}] is a scalar of type {\tt REAL}.
To allow for delayed pivots, the arrays that store the factors and associated
index lists are allocated to accommodate a matrix of order
$s \times max({\tt 1},${\tt multiplier}$)$, where $s$ is the expected size of
the factors without delays.
If, during the factorization, this space is found to be too small, additional
memory will be allocated dynamically.
The default is {\tt multiplier}$ = {\tt 1.1}$.

\item[\texttt{small}] is a scalar of type {\tt REAL}.
Any pivot whose modulus is less than {\tt small} is treated as zero.
The default in the double and double complex versions is
{\tt small}$ = {\tt 10^{-20}}$, and in the single and single complex versions
is {\tt small}$ = {\tt 10^{-12}}$.

\item[\texttt{u}] is a scalar of type {\tt REAL} that holds the relative pivot
tolerance $u$.
The default in the double and double complex versions is {\tt u}$=${\tt 0.01},
and in the single and single complex versions is {\tt u}$=${\tt 0.1}.
Values outside the range $[0,0.5]$ are treated as the closest value in that range.
\end{description}

%%%%%%%%%%% inform type %%%%%%%%%%%

\subsubsection{The derived data type for holding information}
\label{typeinform}
The derived data type {\tt ssids\_info}
is used to hold parameters that give information about the progress and needs
of the algorithm. The components of {\tt ssids\_info}
(in alphabetical order) are:

\begin{description}

\item[\texttt{flag}] is a scalar of type  {\tt INTEGER}
that gives the exit status of the algorithm (details in Section \ref{errors}).

\item[\texttt{flag68}] is a scalar of type  {\tt INTEGER}.
On exit from {\tt ssids\_analyse} or {\tt ssids\_analyse\_coord}, it holds
the exit status from {\tt HSL\_MC68}.


\item[\texttt{flag77}] is a scalar of type  {\tt INTEGER}.
On exit from {\tt ssids\_factor}, it holds
the exit status from {\tt MC77}.

\item[\texttt{matrix\_dup}] is a scalar  of type  {\tt INTEGER}.
On exit from {\tt ssids\_analyse}
with {\tt check} set to {\tt .true.} or from \\
{\tt ssids\_analyse\_coord}, it holds the
number of duplicate entries that were found and summed.

\item[\texttt{matrix\_missing\_diag}] is a scalar of type {\tt INTEGER}.
On exit from {\tt ssids\_analyse} with {\tt check} set to {\tt .true.},
or from {\tt ssids\_analyse\_coord}, it holds the number of diagonal
entries without an explicitly provided value.

\item[\texttt{matrix\_outrange}] is a scalar  of type  {\tt INTEGER}.
On exit from {\tt ssids\_analyse}
with {\tt check} set to {\tt .true.} or from \\
{\tt ssids\_analyse\_coord}, it holds the
number of out-of-range entries that were   found and discarded.

\item[\texttt{matrix\_rank}] is scalar of type  {\tt INTEGER}. On exit from
{\tt ssids\_analyse} and {\tt ssids\_analyse\_coord}, it holds
the structural rank of $A$, if available (otherwise, it is set to {\tt n}).
On exit from
{\tt ssids\_factor}, it holds the computed rank of
the factorized matrix.

\item[\texttt{maxdepth}] is a scalar of type  {\tt INTEGER}. On exit from
{\tt ssids\_analyse}  or {\tt ssids\_analyse\_coord}, it holds the maximum depth of the assembly tree.

\item[\texttt{maxfront}] is a scalar of type  {\tt INTEGER}. On exit from
{\tt ssids\_analyse}  or {\tt ssids\_analyse\_coord}, it holds the maximum front size
in the positive-definite case (or in the indefinite case with
the same pivot sequence). On exit from
{\tt ssids\_factor}, it holds the maximum front size.

\item[\texttt{num\_delay}] is scalar of type  {\tt INTEGER}. On exit from
{\tt ssids\_factor}, it holds the
number of eliminations that were
delayed, that is, the total number of fully-summed
variables that were passed to the father node because
of stability considerations. If a variable is passed
further up the tree, it will be counted again.

\item[\texttt{num\_factor}] is scalar of type {\tt INTEGER(long)}. On exit from
{\tt ssids\_analyse}  or {\tt ssids\_analyse\_coord}, it holds the number of entries that will be in the
factor $L$ in the positive-definite case (or in the indefinite case with
the same pivot sequence). On exit from
{\tt ssids\_factor},
it holds the actual number of entries in the factor
$L$. In the indefinite case, {\tt 2n} entries of ${D}^{-1}$ are
also held.

\item[\texttt{num\_flops}] is scalar of type {\tt INTEGER(long)}. On exit from
{\tt ssids\_analyse}  or {\tt ssids\_analyse\_coord}, it holds the number of
floating-point operations that
will be needed to perform the factorization
in the positive-definite case (or in the indefinite case  with
the same pivot sequence).  On exit from {\tt ssids\_factor}, it holds the
number of floating-point operations performed.

\item[\texttt{num\_neg}] is a scalar  of type  {\tt INTEGER}.
On exit from {\tt ssids\_factor}, it holds
the number of negative eigenvalues of the matrix $D$.


\item[\texttt{num\_sup}] is a scalar of type  {\tt INTEGER}.
On exit from {\tt ssids\_analyse}  or {\tt ssids\_analyse\_coord}, it holds
the number of supernodes in the problem.

\item[\texttt{num\_two}] is scalar of type  {\tt INTEGER}.
On exit from
{\tt ssids\_factor}, it holds the number
of $2 \times 2$ pivots used by the factorization, that is,
the number of $2 \times 2$ blocks in $D$.

\item[\texttt{stat}] is a scalar of type  {\tt INTEGER}.
In the event of an allocation or deallocation error, it
holds the Fortran {\tt stat} parameter if it is available
(and is set to {\tt 0} otherwise).

\end{description}


%%%%%%%%%%%%%%%%%%%%%% Warning and error messages %%%%%%%%%%%%%%%%%%%%%%%%

\section{Return codes} \label{errors}

A successful return from a subroutine in the package is indicated by
{\tt info\%flag} having the value zero.
A negative value is associated with an error message that by default will
be output on unit {\tt control\%unit\_error}.

Possible negative values are:

\begin{description}
\item{$-$1} An error has been made in the sequence of calls (this includes
            calling a subroutine after an error that cannot be recovered from).
\item{$-$2} Returned by {\tt ssids\_analyse} and {\tt ssids\_analyse\_coord} if
            {\tt n$<$0}. Also returned by {\tt ssids\_analyse\_coord} if
            {\tt ne$<$1}.
\item{$-$3} Returned by {\tt ssids\_analyse} if there is an error in {\tt ptr}.
\item{$-$4} Returned by {\tt ssids\_analyse} if all the variable indices in one
            or more columns  are out-of-range. Also returned by
            {\tt ssids\_analyse\_coord} if all entries are out-of-range.
\item{$-$7} Returned by {\tt ssids\_factor} if
            {\tt posdef}$=${\tt .false.} and
            {\tt control\%action = .false.} when the matrix is found to be
            singular. The user may reset the matrix values in {\tt val}
            and recall {\tt ssids\_factor}.
\item{$-$8} Returned by {\tt ssids\_factor} if
            {\tt posdef}$=${\tt .true.} and the matrix is found to
            be not positive definite. This may be because the scaling
            {\tt MC64} found the matrix to be singular. The user may reset the
            matrix values in {\tt val} and recall {\tt ssids\_factor}.
\item{$-$9} Returned by {\tt ssids\_factor} if IEEE infinities found in the
            reduced matrix, probably caused by {\tt control\%small} or
            {\tt control\%u} having too small a value. The user may reset
            {\tt control\%small} and/or {\tt control\%u} or may reset the
            matrix values in {\tt val} and recall {\tt ssids\_factor}.
\item{$-$10} Returned by {\tt ssids\_factor}
            if {\tt ssids\_analyse} was called with {\tt check} set to
            {\tt .false.} but {\tt ptr} and/or {\tt row} is not present.
\item{$-$11} Returned by {\tt ssids\_analyse}  and {\tt ssids\_analyse\_coord}
            if {\tt control\%ordering} is out-of-range, or\\
            {\tt control\%ordering}$=${\tt 0} and the user has either failed
            to provide an elimination order or an error has been found
            in the user-supplied elimination order (held in {\tt order}).
\item{$-$12} Returned by {\tt ssids\_solve} if
            there is an error in the size of array {\tt x} (that is,
            {\tt ldx$<$n} or {\tt nrhs$<$1}). The user may reset {\tt ldx}
            and/or {\tt nrhs} and recall
            {\tt ssids\_solve}.
\item{$-$13} Returned by {\tt ssids\_solve} if {\tt job} is out-of-range.
            The user may reset {\tt job} and recall {\tt ssids\_solve}.
\item{$-$14} Returned by {\tt ssids\_enquire\_posdef} if
            {\tt posdef}$=${\tt .false.} on the last call
            to {\tt ssids\_factor}.
\item{$-$15} Returned by {\tt ssids\_enquire\_indef} if
            {\tt posdef}$=${\tt .true.} on the last call to
            {\tt ssids\_factor}.
\item{$-$16} Allocation error. If available, the {\tt stat}
            parameter is returned in {\tt info\%stat}.
            The user may wish to try the more memory conservative codes
            {\tt HSL\_MA86} or {\tt HSL\_MA77}.
\item{$-$17} Returned by {\tt ssids\_analyse} and {\tt ssids\_analyse\_coord} if
            METIS ordering was requested but METIS is not available.
\item{$-$18} Returned by {\tt ssids\_analyse} and
            {\tt ssids\_analyse\_coord} if there is an unexpected
            error  from {\tt HSL\_MC68}. The user is advised to
            ensure that if {\tt ssids\_analyse}
            was called,  {\tt check} was set to {\tt .true.}.
            Further information may be provided by {\tt info\%flag68}.
\item{$-$19} Returned by {\tt ssids\_factor} if there is an unexpected
            error  from {\tt MC77}. The user is advised to
            ensure that if {\tt ssids\_analyse}
            was called,  {\tt check} was set to {\tt .true.}.
            Further information may be provided by {\tt info\%flag77}.
\item{$-$20} Returned by {\tt ssids\_analyse} and {\tt ssids\_analyse\_coord} if
            {\tt control\%ordering}$=${\tt 2}.
\item{$-$21} Returned by {\tt ssids\_factorise} if {\tt control\%scaling$=$3}
            but a matching based ordering was not used during the call to
            {\tt ssids\_analyse} or {\tt ssids\_analyse\_coord} (i.e. was
            called with
            {\tt control\%ordering}$\ne${\tt 2}).
\end{description}
A positive value of {\tt info\%flag}
is used to warn the user that the input matrix data may be faulty or that
the subroutine cannot guarantee the solution obtained.
Possible values are:
\begin{description}
\item{$+$1} Returned by {\tt ssids\_analyse}
and {\tt ssids\_analyse\_coord} if out-of-range variable
indices found.
Any such entries are ignored  and the computation continues.
{\tt info\%matrix\_outrange} is set to the number of such entries.

\item{$+$2} Returned by {\tt ssids\_analyse} and {\tt ssids\_analyse\_coord}
if duplicated indices found. Duplicates are recorded and the corresponding
entries are summed. {\tt info\%matrix\_dup} is set to the number of such entries.

\item{$+$3} Returned by {\tt ssids\_analyse}  and {\tt ssids\_analyse\_coord} if both
out-of-range and duplicated variable indices found.

\item{$+$4} Returned by {\tt ssids\_analyse}  and {\tt ssids\_analyse\_coord}
if  one and more diagonal entries
of $A$ is missing.

\item{$+$5} Returned by {\tt ssids\_analyse}  and {\tt ssids\_analyse\_coord}
if  one and more diagonal entries
of $A$ is missing  and
out-of-range and/or duplicated variable indices have been found.

\item{$+$6} Returned by {\tt ssids\_analyse}  and {\tt ssids\_analyse\_coord} if
$A$ is found be (structurally) singular. This will overwrite any of the above warnings.

\item{$+$7} Returned by {\tt ssids\_factor} if {\tt control\%action} is set
to {\tt .true.} and the matrix is found to be (structurally or numerically)
singular.

\item{$+$8} Returned by {\tt ssids\_factor} if
{\tt control\%ordering}$=${\tt 2} (i.e.
a matching-based ordering was used) but the associated scaling was not (i.e. {\tt control\%scaling}$\ne$
{\tt 3}).

\end{description}

\section{Method} \label{method}


\vspace{0.2in}
\noindent {\tt ssids\_analyse} and {\tt ssids\_analyse\_coord} \\
If {\tt check} is set to {\tt .true.} on the call to {\tt ssids\_analyse}
or if {\tt ssids\_analyse\_coord} is called, the HSL package
{\tt HSL\_MC69} is used to check the matrix data. The cleaned integer matrix data
(duplicates are summed and out-of-range indices discarded) is stored in
{\tt akeep}.
The use of checking is optional on a call to {\tt ssids\_analyse} as it
incurs both time and memory overheads. Some form of checking is recommended
since the behaviour of the other routines in the package
is unpredictable if duplicates and/or out-of-range variable indices are entered.
Calling the \texttt{HSL\_MC69} routine \texttt{mc69\_verify} offers an
alternative that can be used for debugging purposes.

If the user has supplied a pivot order it is checked for errors. Otherwise,
a pivot order is generated using {\tt HSL\_MC68}, or if a matching-based ordering is
requested, {\tt HSL\_MC80}.
The pivot order is used to construct the assembly tree
using {\tt HSL\_MC78}.

On exit, {\tt order} is set so that {\tt order(i)} holds the position
at which variable {\tt i} is eliminated. If a user order was supplied, this
order may differ, but will be equivalent in terms of fill-in to that provided.


If a matching-based ordering is requested and {\tt scale} is present, on exit,
{\tt scale} contains scaling factors computed by {\tt MC64}.
These may be passed unchanged to {\tt ssids\_factor}.

\vspace{0.2in}
\noindent {\tt  ssids\_factor}\\
{\tt ssids\_factor} optionally computes
a scaling and then perform the numerical factorization.
 The user must specify whether or not the matrix is
positive definite. If {\tt posdef} is {\tt .true.}, no pivoting
is performed. As a result the computation will terminate with an error if a
non-positive pivot is encountered.

The factorization uses the assembly tree that was set up by the analyse phase.
If running on a single thread (or if there is insufficient work available to
justify running in parallel), the nodes of the tree are iterated over in a
post-order.

At a node, the contributions from the children relating to those columns
that are fully summed at this node are first assembled. A dense partial
factorization is then performed on these columns. In the positive-definite case,
LAPACK's \texttt{\_potrf} (or \texttt{\_herk} for Hermitian matrices) is used.
In the indefinite case, an algorithm based on the same pivoting algorithm as
\texttt{HSL\_MA64} is used.

The generated element is calculated by first forming the outer product of the
fully summed columns' uneliminated rows. The contributions from the
children are then added, and the stack memory used by the children is freed.
As this involves copying from one stacked contribution to another,
two separate stacks are used to do this.

If a pivot candidate does not pass pivot tests at a given node, it is delayed
to the parent node where additional eliminations may make the pivot feasible.
This results in the generation of additional fill-in and floating-point
operations, and may result in additional memory allocations being required.

In parallel computation, we exploit two levels of parallelism using OpenMP
tasks.
In tree-level parallelism, different subtrees are factorized in independent
tasks. To ensure results are bit-compatible regardless of the number of threads
used, the assembly order of the children is fixed at assembly time.
In node-level parallelism, the operations forming the outer-product in both the
dense factorization kernel and the calculation of the generated element are
broken into multiple tasks. Bit-compatibility is ensured in this case by using
a data-parallel approach so each individual sum is effectively calculated in
serial.

\vspace{0.2in}
\noindent {\tt ssids\_solve}\\
Having checked the user's data, {\tt ssids\_solve} performs a forward
substitution followed by a combined diagonal solve and back substitution
(unless only one of these is requested).

In a supernodal solve updates are done directly into the right-hand side vector
and do not readily admit bit-compatible parallelism in the forward substitution.
In the multifrontal solve updates are passed up the tree utilising a stack. This
allows parallelism to be implemented but can be slower than the supernodal
solve on small problems.
Regardless of whether a supernodal or multifrontal solve is chosen the same
backwards solve is used that works directly on the right-hand side vectors. Due
to the differing data dependencies from the forward substitution a
bit-compatible parallel solve is possible.

The matrix factor must be accessed once for the
forward substitution and once for the back substitution. This is
independent of the number of right-hand sides so that solving for
several right-hand sides at once is significantly faster
than repeatedly solving for a single right-hand side.

\subsection*{References}
[1] J.D. Hogg and J.A. Scott. (2011).
{\tt HSL\_MA97}: a bit-compatible multifrontal code for sparse symmetric
systems.
RAL Technical Report. RAL-TR-2011-024.



%%%%%%%%%%%%%%%%%%%%%% EXAMPLE %%%%%%%%%%%%%%%%%%%%%%%%

\section{Examples} \label{examples}

\subsection{First example: sparse column entry}
Suppose we wish to factorize the matrix
\[ A = \left(
\begin{array}{ccccc}
2. & 1. \\
1. & 4. & 1. & & 1. \\
 & 1. & 3. & 2. \\
& & 2. & 0. &  \\
& 1. & & & 2.
\end{array}
\right)
\]
and then solve for the right-hand side
\[ B = \left(
\begin{array}{c}
4. \\
12. \\
10. \\
4. \\
4.
\end{array}
\right).
\]

\noindent
The following code may be used.
\begin{verbatim}
! Simple code to illustrate use of spral_ssids
program ssidsds
   use spral_ssids
   implicit none

   ! Derived types
   type (ssids_akeep)   :: akeep
   type (ssids_fkeep)   :: fkeep
   type (ssids_control) :: control
   type (ssids_info)    :: info

   ! Parameters
   integer, parameter :: wp = kind(0.0d0)

   integer, dimension (:),  allocatable :: ptr
   integer, dimension (:),  allocatable :: piv_order
   integer, dimension (:),  allocatable :: row
   real(wp), dimension (:), allocatable :: val
   real(wp), dimension (:), allocatable :: x
   real(wp), dimension (:,:), allocatable :: d

   integer :: matrix_type,n,ne
   logical :: check

   ! Read in the order n of the matrix and number of entries in lower triangle
   read (*,*) n,ne

   ! Allocate arrays for matrix data and arrays for ssids
   allocate (ptr(n+1),row(ne),val(ne))
   allocate (x(n),d(2,n))

   read (*,*) ptr(1:n+1)
   read (*,*) row(1:ne)
   read (*,*) val(1:ne)

   ! Perform analyse and factorise with data checking
   check = .true.
   call ssids_analyse(check,n,ptr,row,akeep,control,info)
   if (info%flag < 0) go to 100
   matrix_type = 4 ! Real, symmetric indefinite
   call ssids_factor(matrix_type,val,akeep,fkeep,control,info)
   if (info%flag < 0) go to 100

   ! Read in the right-hand side and copy into resid.
   read (*,*) x(1:n)

   ! Solve
   call ssids_solve(x,akeep,fkeep,control,info)
   if (info%flag < 0) go to 100
   write (*,'(/a,/,(3es18.10))') ' The computed solution is:', x(1:n)

   ! Determine the pivot order used
   allocate (piv_order(1:n))
   call ssids_enquire_indef(piv_order, d, akeep, fkeep, control, info)
   write (6,*) 'piv_order', piv_order(1:n)

   100 continue
   call ssids_finalise(akeep, fkeep)

end program ssidsds
\end{verbatim}
\noindent
with the following data:
\begin{verbatim}
  5  8
  1  3  6  8  8  9
  1  2  2  5  3  4  3  5
  2. 1. 4. 1. 1. 2. 3. 2.
  4. 12. 10. 4. 4.
\end{verbatim}
\noindent
This produces the following output:
\begin{verbatim}
 The computed solution is:
     1.000     2.000     2.000     1.000     1.000
\end{verbatim}

\subsection{Second example: coordinate entry, refactorization}
{\bf FIXME: Remove factor\_solve}
Suppose we wish to factorize the matrix
\[ A = \left(
\begin{array}{ccccc}
1. & -3. & & 1. \\
-3. & -5. & 6. & & 4.\\
& 6. & & 2. \\
1. & & 2. & 3. \\
& 4. & & & 1.
\end{array}
\right)
\]
and then solve for the right-hand sides
\[ B = \left(
\begin{array}{cc}
-1. & -5.\\
25. & -40. \\
20. & 8. \\
19. & -8. \\
13. & -1.
\end{array}
\right)
\].
Suppose we then wish to solve the following system with the same pattern in a
single call:
\[ \left(
\begin{array}{ccccc}
2. & 1. & & 7. \\
1. & 1. & 8. & & 2.\\
& 8. & & 1. \\
7. & & 1. & 8. \\
& 2. & & & 8.
\end{array}
\right) \mathbf{x} = \left(
\begin{array}{c}
8. \\
89. \\
40. \\
37. \\
42.
\end{array}
\right)
\]

\noindent
The following code may be used.
\begin{verbatim}
! Simple code to illustrate use of spral_ssids
program ssidsds1
   use spral_ssids
   implicit none

   ! Derived types
   type (ssids_akeep)   :: akeep
   type (ssids_fkeep)   :: fkeep
   type (ssids_control) :: control
   type (ssids_info)    :: info

   ! Parameters
   integer, parameter :: wp = kind(0.0d0)

   integer, dimension (:),  allocatable :: row
   integer, dimension (:),  allocatable :: col
   real(wp), dimension (:), allocatable :: val
   real(wp), dimension (:,:), allocatable :: x

   integer :: matrix_type,n,ne,cuda_error

   ! Read in the order n of the matrix and number of entries in lower triangle
   read (*,*) n,ne

   ! Allocate arrays for matrix data and arrays for ssids
   allocate (row(ne),col(ne),val(ne))
   allocate (x(n,2))

   read (*,*) row(1:ne)
   read (*,*) col(1:ne)
   read (*,*) val(1:ne)

   ! Perform analyse and factorise with coordinate input
   call ssids_analyse_coord(n,ne,row,col,akeep,control,info)
   if (info%flag < 0) go to 100
   matrix_type = 4 ! Real, symmetric indefinite
   call ssids_factor(matrix_type,val,akeep,fkeep,control,info)
   if (info%flag < 0) go to 100

   ! Read in the right-hand side
   read (*,*) x(1:n,1:2)

   ! Solve
   call ssids_solve(2,x,n,akeep,fkeep,control,info)
   if (info%flag < 0) go to 100
   write (*,'(/a,/,(3es18.10))') ' The computed solution is:', x(1:n,1)
   write (*,'(3es18.10)') x(1:n,2)

   ! Read values of second matrix with same pattern
   read (*,*) val(1:ne)

   ! Read another right hand side
   read (*,*) x(1:n,1)

   ! Perform combined factor and solve
   call ssids_factor_solve(matrix_type,val,x(1:n,1),akeep,fkeep,control,info)
   write (*,'(/a,/,(3es18.10))') ' Next solution is:', x(1:n,1)

   100 continue
   call ssids_finalise(akeep, fkeep, cuda_error)

end program ssidsds1
\end{verbatim}
\noindent
with the following data:
\begin{verbatim}
5 9
1   2   1   2   3   5   4   4   5
1   1   4   2   2   2   4   3   5
1. -3.  1. -5.  6.  4.  3.  2.  1.
-1.  25.  20.  19.  13.
-5. -40.   8.  -8.  -1.
2.  1.  7.  1.  8.  2.  8.  1.  8.
16.5 89.0 40.5 41.0 42.0
\end{verbatim}
\noindent
This produces the following output:
\begin{verbatim}

 Warning from ssids_analyse_coord. Warning flag =   4
 one or more diagonal entries is missing

 The computed solution is:
  1.0000000000E+00  2.0000000000E+00  3.0000000000E+00
  4.0000000000E+00  5.0000000000E+00
 -3.0000000000E+00  1.0000000000E+00 -4.0000000000E+00
  1.0000000000E+00 -5.0000000000E+00

 Next solution is:
  4.0000000000E+00  5.0000000000E+00  9.0000000000E+00
  5.0000000000E-01  4.0000000000E+00
\end{verbatim}
Note that the warning is entirely innocous and is merely due to the absence of
a non-zero in the diagonal $(3,3)$ position.

\begin{funders}
   \funder{epsrc}{Funded by EPSRC grant EP/J010553/1}
\end{funders}

\end{document}
