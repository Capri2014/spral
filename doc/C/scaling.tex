\packagename{SCALING}
\version{1.0.0}
\versiondate{3 December 2014}
\purpose{
   This package generates various scalings (and matchings) of sparse matrices.

   Given a real \textbf{symmetric} matrix $A$, it finds a digaonal matrix $D$ such
   that the scaled matrix
   $$
      \hat{A} = DAD
   $$
   has specific numerical properties.

   Given a real \textbf{unsymmetric} matrix $A$, it finds diagonal matrices $D_r$
   and $D_c$ such that the scaled matrix
   $$
      \hat{A} = D_r A D_c
   $$
   has specific numerical properties.

   The exact nature of $\hat{A}$ in both cases depends on the algorithm used.
   \begin{description}
      \item[Matching-based] algorithms scale $A$ such that the maximum
         (absolute) value in each row and column of $\hat{A}$ is exactly 1.0,
         where the entries of maximum value form a maximum cardinality matching.
         The \textbf{Hungarian algorithm} delivers an optimal answer slowly,
         whereas the \textbf{auction algorithm} delivers an approximate
         answer quickly.
      \item[Norm-equilibriation] algorithms scale $A$ such that the infinity
         norm of each row and column of $\hat{A}$ is exactly 1.0.
   \end{description}
}

\title{Sparse Matrix Scalings}
\author{
   Jonathan Hogg (STFC Rutherford Appleton Laboratory) \\
}
\pkglang{C}
\spralmaketitle
\thispagestyle{firststyle}

\section*{Major version history}
\begin{description}
\item[2014-12-03 Version 1.0.0] Development version
\end{description}

%%%%%%%%%%%%%%%%%%%%%% installation %%%%%%%%%%%%%%%%%%%%%%

\section{Installation}
Please see the SPRAL install documentation.

%%%%%%%%%%%%%%%%%%%%%% how to use %%%%%%%%%%%%%%%%%%%%%%%%

\section{Usage overview}

\subsection{Calling sequences}

Access to the package requires inclusion of either \texttt{spral.h} (for the
entire \spral library) or \texttt{spral\_ssids.h} (for just the relevant routines). i.e.

\begin{verbatim}
   #include "spral.h"
\end{verbatim}

\noindent
The following functions are available to the user:
\begin{itemize}
\item {\tt spral\_scaling\_default\_auction\_options()} initializes the options structure for the auction algorithm.
\item {\tt spral\_scaling\_default\_equilib\_options()} initializes the options structure for the norm equilibriation algorithm.
\item {\tt spral\_scaling\_default\_hungarian\_options()} initializes the options structure for the Hungarian algorithm.
\item {\tt spral\_scaling\_hungarian\_sym()} generates a matching-based scaling for a symmetric matrix using the Hungarian algorithm.
\item {\tt spral\_scaling\_auction\_sym()} generates a matching-based scaling for a symmetric matrix using an auction algorithm.
\item {\tt spral\_scaling\_equilb\_sym()} generates a norm equilibriation scaling for a symmetric matrix.
\end{itemize}

\subsection{Data formats} \label{dataformats}

\begin{figure}
   \caption{ \label{format eg}
      Data format example matrix (symmetric)
   }
   $$
      \left( \begin{array}{ccccc}
         1.1 & 2.2 &     & 3.3 &     \\
         2.2 &     & 4.4 &     &     \\
             & 4.4 & 5.5 &     & 6.6 \\
         3.3 &     &     & 7.7 & 8.8 \\
             &     & 6.6 & 8.8 & 9.9
      \end{array} \right)
   $$
\end{figure}

\subsubsection{Compressed Sparse Column (CSC) Format} \label{cscformat}
This standard data format consists of the following data:
\begin{verbatim}
   int    n;                  /* size of matrix */
   int    ptr[ n+1 ];         /* column pointers */
   int    row[ ptr[n]-1 ];    /* row indices */
   double val[ ptr[n]-1 ];    /* numerical values */
\end{verbatim}
Non-zero matrix entries are ordered by increasing column index and stored in
the arrays \texttt{row[]} and \texttt{val[]} such that \texttt{row[k]} holds
the row number and \texttt{val[k]} holds the value of the \texttt{k}-th entry.
The \texttt{ptr[]} array stores column pointers such that \texttt{ptr[i]} is
the position in \texttt{row[]} and \texttt{val[]} of
the first entry in the \texttt{i}-th column, and \texttt{ptr[n]} is one more
than the total number of entries.
Entries that are zero, including those on the diagonal, need not be specified.

For symmetric matrices, only the lower triangular entries of $A$, should be
supplied, and there must be no duplicate entries. 

To illustrate the CSC format, the following arrays describe the matrix shown in
Figure~\ref{format eg}.
\begin{verbatim}
   int n = 5;
   int ptr[]    = { 0,             3,   4,        6,        8,    9 };
   int row[]    = { 0,   1,   3,   2,   2,   4,   3,   4,   4 };
   double val[] = { 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9 };
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%% argument lists %%%%%%%%%%%%%%%%%%%%%%%%

\section{High-level Subroutines}

\subsection{\texttt{spral\_scaling\_auction\_default\_options()}, 
   \texttt{spral\_scaling\_equilib\_default\_options()} and
   \texttt{spral\_scaling\_hungarian\_default\_options()}}

%%%%%%%%% options initialization subroutines %%%%%%%

\textbf{To initialize a variable of type
   \texttt{struct spral\_scaling\_auction\_options} the following routine
   is provided.}

\vspace*{0.1cm}
\noindent
\textbf{\texttt{
   \hspace*{0.3cm} void spral\_scaling\_auction\_default\_options(struct spral\_scaling\_auction\_options *options);
}}

\noindent
\textbf{To initialize a variable of type
   \texttt{struct spral\_scaling\_equilib\_options} the following routine
   is provided.}

\vspace*{0.1cm}
\noindent
\textbf{\texttt{
   \hspace*{0.3cm} void spral\_scaling\_equilib\_default\_options(struct spral\_scaling\_equilib\_options *options);
}}

\noindent
\textbf{To initialize a variable of type
   \texttt{struct spral\_scaling\_hungarian\_options} the following routine
   is provided.}

\vspace*{0.1cm}
\noindent
\textbf{\texttt{
   \hspace*{0.3cm} void spral\_scaling\_hungarian\_default\_options(struct spral\_scaling\_hungarian\_options *options);
}}

\noindent
\begin{description}
   \item[\texttt{*options}] is the instance to be initialized.
\end{description}

%%%%%%%%% Auction %%%%%%

\subsection{\texttt{spral\_scaling\_auction\_sym()}}

\textbf{\noindent
   To generate a scaling for a real symmetric matrix using an auction algorithm such that the entry of maxmimum absolute value in each row and column is 1.0,
}
\vspace*{-0.1cm}
\begin{verbatim}
   void spral_scaling_auction_sym(int n, const int *ptr, const int *row, const double *val,
      double *scaling, int *match, const struct spral_scaling_auction_options *options,
      struct spral_scaling_auction_inform *inform);
\end{verbatim}

\begin{description}

\item[\texttt{n}, \texttt{ptr[n+1]}, \texttt{row[ptr[n]]}, \texttt{val[ptr[n]]}] must hold the lower triangular part of $A$ in compressed sparse column format as described in Section~\ref{cscformat}.

\item[\texttt{scaling[n]}] holds, on exit, the diagonal of $D$.
\texttt{scaling[i]} will hold $D_{ii}$, the scaling corresponding to the
\texttt{i}-th row and column.

\item[\texttt{match[n]}] may be \texttt{NULL}. If it is non-\texttt{NULL},
then on exit it specifies the matching of rows to columns.
Column \texttt{i} is matched to row \texttt{match[i]}.

\item[\texttt{*options}] specifies the algorithmic options used by the subroutine, as explained in Section~\ref{type:hungarian_options}.

\item[\texttt{*inform}] is used to return information about the execution of the subroutine, as explained in Section~\ref{type:hungarian_inform}.


\end{description}

%%%%%%%%% Equilibriation %%%%%%

\subsection{\texttt{spral\_scaling\_equilib\_sym()}}

\textbf{\noindent
   To generate a scaling for a real symmetric matrix using a norm equilibriation algorithm such that the infinity norm of each row and column is equal,
}
\vspace*{-0.1cm}
\begin{verbatim}
   void spral_scaling_equilib_sym(int n, const int *ptr, const int *row, const double *val,
      double *scaling, const struct spral_scaling_equilib_options *options,
      struct spral_scaling_equilib_inform *inform);
\end{verbatim}

\begin{description}

\item[\texttt{n}, \texttt{ptr[n+1]}, \texttt{row[ptr[n]]}, \texttt{val[ptr[n]]}] must hold the lower triangular part of $A$ in compressed sparse column format as described in Section~\ref{cscformat}.

\item[\texttt{scaling[n]}] holds, on exit, the diagonal of $D$.
\texttt{scaling[i]} will hold $D_{ii}$, the scaling corresponding to the
\texttt{i}-th row and column.

\item[\texttt{*options}] specifies the algorithmic options used by the subroutine, as explained in Section~\ref{type:hungarian_options}.

\item[\texttt{*inform}] is used to return information about the execution of the subroutine, as explained in Section~\ref{type:hungarian_inform}.


\end{description}

%%%%%%%%% Hungarian %%%%%%

\subsection{\texttt{spral\_scaling\_hungarian\_sym()}}

\textbf{\noindent
   To generate a scaling for a real symmetric matrix using the Hungarian algorithm such that the entry of maxmimum absolute value in each row and column is 1.0,
}
\vspace*{-0.1cm}
\begin{verbatim}
   void spral_scaling_hungarian_sym(int n, const int *ptr, const int *row, const double *val,
      double *scaling, int *match, const struct spral_scaling_hungarian_options *options,
      struct spral_scaling_hungarian_inform *inform);
\end{verbatim}

\begin{description}

\item[\texttt{n}, \texttt{ptr[n+1]}, \texttt{row[ptr[n]]}, \texttt{val[ptr[n]]}] must hold the lower triangular part of $A$ in compressed sparse column format as described in Section~\ref{cscformat}.

\item[\texttt{scaling[n]}] holds, on exit, the diagonal of $D$.
\texttt{scaling[i]} will hold $D_{ii}$, the scaling corresponding to the
\texttt{i}-th row and column.

\item[\texttt{match[n]}] may be \texttt{NULL}. If it is non-\texttt{NULL},
then on exit it specifies the matching of rows to columns.
Column \texttt{i} is matched to row \texttt{match[i]}.

\item[\texttt{*options}] specifies the algorithmic options used by the subroutine, as explained in Section~\ref{type:hungarian_options}.

\item[\texttt{*inform}] is used to return information about the execution of the subroutine, as explained in Section~\ref{type:hungarian_inform}.


\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Derived types}
\subsection{\texttt{struct spral\_scaling\_auction\_options}} \label{type:auction_options}

The structure \texttt{spral\_scaling\_auction\_options} is used to specify the options
used by the routine \\\texttt{spral\_scaling\_auction\_sym()}. The components, that
must be given default values through a call to \texttt{spral\_scaling\_default\_auction\_options()}, are:

\begin{description}

\item[\texttt{int array\_base}] specifies the array indexing base. It must
   have the value either \texttt{0} (C indexing) or \texttt{1} (Fortran
   indexing). If \texttt{array\_base}$=$\texttt{1}, the entries of arrays
   \texttt{ptr[]},\texttt{row[]} and \texttt{match[]} start at 1, not 0.
   Further, entries of \texttt{match[]} that are unmatched are indicated by a
   value of \texttt{0}, not \texttt{-1}.
   The default value is \texttt{array\_base}$=$\texttt{0}.

\item[\texttt{int max\_iterations}] specifies the maximum number of iterations the algorithm may perform. The default is \texttt{max\_iterations}$=$\texttt{30000}.

\item[\texttt{int max\_unchanged[3]}] specifies, together with \texttt{min\_proportion[]}, the termination conditions for the algorithm, as described in Section~\ref{method:auction}. The default is \texttt{max\_unchanged[]} $=$ \texttt{\{ 10, 100, 100 \}}.

\item[\texttt{float min\_proportion[3]}] specifies, together with \texttt{max\_unchanged(:)}, the termination conditions for the algorithm, as described in Section~\ref{method:auction}. The default is \texttt{max\_unchanged[]} $=$ \texttt{\{ 0.90, 0.0, 0.0 \}}.

\item[\texttt{float eps}] specifies the initial value of the minimum improvement parameter $\epsilon$ as described in Section~\ref{method:auction}.

\end{description}

\subsection{\texttt{struct spral\_scaling\_auction\_inform}} \label{type:auction_inform}

The structure \texttt{spral\_scaling\_auction\_inform} is used to hold parameters that
give information about the progress of the routine
\texttt{spral\_scaling\_auction\_sym()}. The components are:

\begin{description}

\item[\texttt{int flag}] gives the exit status of the algorithm (details in Section~\ref{error flags}).

\item[\texttt{int iterations}] holds the number of iterations performed.

\item[\texttt{int matched}] holds the number of rows and columns that have been matched.

\item[\texttt{int stat}] holds, in the event of an allocation error or deallocation error, the Fortran \texttt{stat} parameter if it is available (and is set to \texttt{0} otherwise).

\end{description}

\subsection{\texttt{struct spral\_scaling\_equilib\_options}} \label{type:equilib_options}

The structure \texttt{spral\_scaling\_equilib\_options} is used to specify the options
used by the routine \\\texttt{spral\_scaling\_equilib\_sym()}. The components, that
must be given default values through a call to \texttt{spral\_scaling\_default\_equilib\_options()}, are:

\begin{description}

\item[\texttt{int array\_base}] specifies the array indexing base. It must
   have the value either \texttt{0} (C indexing) or \texttt{1} (Fortran
   indexing). If \texttt{array\_base}$=$\texttt{1}, the entries of arrays
   \texttt{ptr[]} and \texttt{row[]} start at 1, not 0.
   Further, entries of \texttt{match[]} that are unmatched are indicated by a
   value of \texttt{0}, not \texttt{-1}.
   The default value is \texttt{array\_base}$=$\texttt{0}.

\item[\texttt{int max\_iterations}] specifies the maximum number of iterations the algorithm may perform. The default is \texttt{max\_iterations}=\texttt{10}.

\item[\texttt{float tol}] specifies the convergence tolerance for the algorithm (though often termination is based on \texttt{max\_iterations}). The default is \texttt{tol} = \texttt{1e-8}.

\end{description}

\subsection{\texttt{struct spral\_scaling\_equilib\_inform}} \label{type:equilib_inform}

The structure \texttt{spral\_scaling\_equilib\_inform} is used to hold parameters that
give information about the progress of the routine
\texttt{spral\_scaling\_equilib\_sym()}. The components are:

\begin{description}

\item[\texttt{int flag}] gives the exit status of the algorithm (details in Section~\ref{error flags}).

\item[\texttt{int stat}] holds, in the event of an allocation error or deallocation error, the Fortran \texttt{stat} parameter if it is available (and is set to \texttt{0} otherwise).
\end{description}

\subsection{\texttt{struct spral\_scaling\_hungarian\_options}} \label{type:hungarian_options}

The structure \texttt{spral\_scaling\_hungarian\_options} is used to specify the
options used by the routine \\\texttt{spral\_scaling\_hungarian\_sym()}. The components,
that must be given default values through a call to \texttt{spral\_scaling\_default\_hungarian\_options()}, are:

\begin{description}

\item[\texttt{int array\_base}] specifies the array indexing base. It must
   have the value either \texttt{0} (C indexing) or \texttt{1} (Fortran
   indexing). If \texttt{array\_base}$=$\texttt{1}, the entries of arrays
   \texttt{ptr[]},\texttt{row[]} and \texttt{match[]} start at 1, not 0.
   Further, entries of \texttt{match[]} that are unmatched are indicated by a
   value of \texttt{0}, not \texttt{-1}.
   The default value is \texttt{array\_base}$=$\texttt{0}.

\item[\texttt{bool scale\_if\_singular}]
specifies whether scaling shuold continue if the matrix $A$ is found to be
structurally singular. If \texttt{scale\_if\_singular}$=$\texttt{true},
and the $A$ is structurally singular, a partial scaling corresponding to a
maximum cardinality matching will be returned and a warning issued. Otherwise
an identity scaling will be returned and an error issued.

\end{description}

\subsection{\texttt{struct spral\_scaling\_hungarian\_inform}} \label{type:hungarian_inform}

The structure \texttt{spral\_scaling\_hungarian\_inform} is used to hold parameters
that give information about the progress of the routine
\texttt{spral\_scaling\_hungarian\_sym()}. The components are:

\begin{description}

\item[\texttt{int flag}] gives the exit status of the algorithm (details in Section~\ref{error flags}).

\item[\texttt{int stat}] holds, in the event of an allocation error or deallocation error, the Fortran \texttt{stat} parameter if it is available (and is set to \texttt{0} otherwise).
\end{description}

%%%%%%%%%%%%%% ERROR FLAGS %%%%%%%%%%%%%%%%%%%%%%

\section{Error Flags} \label{error flags}
A successful return from a routine is indicated by \texttt{inform.flag} having the value zero. A negative value is associated with an error message and a positive value with a warning.

Possible negative (error) values are:
\begin{description}
\item[\texttt{-1}] Allocation error. If available, the Fortran \texttt{stat} parameter is returned in \texttt{inform.stat}.
\item[\texttt{-2}] Matrix $A$ is structurally rank-deficient. This error is only
   returned by \texttt{spral\_scaling\_hungarian\_sym()} and only if
   \texttt{options.scale\_if\_singular}$=$\texttt{false}. The scaling vector
   will be set to \texttt{1.0} and a matching of maximum cardinality returned
   in the optional argument \texttt{match[]}, if present.
\end{description}

Possible positive (warning) values are:
\begin{description}
\item[\texttt{+1}] Matrix $A$ is structurally rank-deficient. This warning is
   only returned by \texttt{spral\_scaling\_hungarian\_sym()} and only if
   \texttt{options.scale\_if\_singular}$=$\texttt{true}.
\end{description}

%%%%%%%%%%%%%% METHOD %%%%%%%%%%%%%%%%%%%%%%

\section{Method} \label{method}

\subsection{Matching-based algorithms}

Matching-based scaling algorithms first solve the maximum product optimization
problem
\begin{eqnarray*}
   \max_{\sigma} & \prod_{i=1}^m\prod_{j=1}^n |a_{ij}|\sigma_{ij} & \\
   \mathrm{s.t.} & \sum_{i=1}^m\sigma_{ij} = 1, & \forall j=1,n \\
                 & \sum_{j=1}^n\sigma_{ij} = 1, & \forall i=1,m \\
                 & \sigma_{ij} \in \{0,1\}.
\end{eqnarray*}
The array $\sigma$ gives a matching of rows to columns.

By using the transformation
$$
   w_{ij} = \log c_j - \log |a_{ij}|,
$$
where $c_j = \max_i |a_{ij}|$, the maximum product problem in $a_{ij}$ is
replaced by a minimum sum problem in $w_{ij}$ where all entries are positive.
By standard optimization theory we have dual variables $u$ and $v$ corresponding
to the constraints. These satisfy first order optimality conditions
\begin{eqnarray*}
   w_{ij} - u_i - v_j = 0, && \mbox{if } \sigma_{ij }=1, \\
   w_{ij} - u_i - v_j \ge 0, && \mbox{if } \sigma_{ij }=0.
\end{eqnarray*}
To obtain a scaling we define scaling matrices $D_r$ and $D_c$ as
\begin{eqnarray*}
   & d^r_i = e^{u_i}, & \\
   & d^c_i = e^{v_i}. &
\end{eqnarray*}
If a symmetric scaling is required, we average these as
$$
   d_i = \sqrt{d^r_id^c_i}.
$$
By the first order optimality conditions, these scaling matrices guarantee that
\begin{eqnarray*}
   d^r_i|a_{ij}|d^c_j = 1, && \mbox{if } \sigma_{ij}=1, \\
   d^r_i|a_{ij}|d^c_j \le 1, && \mbox{if } \sigma_{ij}=0.
\end{eqnarray*}

The Hungarian and Auction algorithms vary by the algorithm used to solve the
minimum sum problem.

\subsubsection{Hungarian algorithm}
This is the same algorithm as used by the HSL routine MC64.
The Hungarian algorithm works by maintaining an optimal matching on a subset of
the rows and columns. It proceeds to grow this set by finding augmenting paths
from an unmatched row to an unmatched column. The algorithm is guaranteed to
find the optimal solution in a fixed number of steps, but can be very slow as
it may need to explore the full matrix a number of times equal to the dimension
of the matrix. To minimize the solution time, a warmstarting heuristic is used
to construct an initial optimal subset matching.

\noindent
Further detail is given in the following paper:
\begin{itemize}
   \item[{[1]}] I.S. Duff and J. Koster. (1997). The design and use of algorithms for permuting large entries to the diagonal of sparse matrices. SIAM J. Matrix Anal. Applics. 20(4), pp 889--901.
\end{itemize}

\subsubsection{Auction algorithm} \label{method:auction}
The auction algorithm is not guaranteed to find an optimal matching, however it
can find an approximate matching very quickly. A matching is maintained along
with the row pricing vector $u$ (the other dual variable $v$ can be easily
calculated from knowledge of $u$ and the $\sigma$ after completion of the
algorithm). In each major iteration we loop over each column in turn. If the
column $j$ is unmatched we calculate the value $p_i = w_{ij} - u_i$ for each
entry and find the maximum across the column. If this maximum is positive, the
current matching can be improved by matching column $j$ with row $i$. This may
mean that the previous match of row $i$ now becomes unmatched. We update the
price of row $i$, that is $u_i$ to reflect this new benefit and continue to the
next column.

To prevent incremental shuffling, we insist that the value of
adding a new column is at least a threshold value $\epsilon$ above zero, where
$\epsilon$ is based on the last iteration in which row $i$ changed its match.
This is done by adding $\epsilon$ to the price $u_i$, where $\epsilon = \texttt{options.eps} + \texttt{itr} / (n+1)$.

The algorithm terminates if:
\begin{itemize}
   \item All entries are matched
   \item The number of major iterations exceeds \texttt{options.max\_iterations}.
   \item At least \texttt{options.max\_unchanged(1)} iterations have passed without the cardinality of the matching increasing, and the proportion of matched columns is \texttt{options.min\_proportion(1)}.
   \item At least \texttt{options.max\_unchanged(2)} iterations have passed without the cardinality of the matching increasing, and the proportion of matched columns is \texttt{options.min\_proportion(2)}.
   \item At least \texttt{options.max\_unchanged(3)} iterations have passed without the cardinality of the matching increasing, and the proportion of matched columns is \texttt{options.min\_proportion(3)}.
\end{itemize}

\noindent
Further detail is given in the following paper:
\begin{itemize}
   \item[{[2]}] J.D. Hogg and J.A. Scott. (2014). On the efficient scaling of sparse symmetric matrices using an auction algorithm. RAL Technical Report RAL-P-2014-002.
\end{itemize}

\subsection{Norm equilibriation algorithm}
This is similar to the algorithm used by the HSL routine MC77.
An iterative method
is used to scale the infinity norm of both rows and columns to 1 with an asymptotic linear rate of convergence of $\frac{1}{2}$, preserving symmetry if the matrix is symmetric.

\noindent
Further detail is given in the following paper:
\begin{itemize}
   \item[{[3]}] P. Knight, D. Ruiz and B. Ucar. (2012). A symmetry Preserving Algorithm for Matrix Scaling. INRIA Research Report 7552.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%% EXAMPLE %%%%%%%%%%%%%%%%%%%%%%%%

\section{Examples} \label{examples}

\subsection{spral\_scaling\_auction\_sym()}
The following example code:
\verbatiminput{examples/C/scaling/auction_sym.c}
Produces the following output:
\begin{verbatim}
Initial matrix:
Real symmetric indefinite matrix, dimension 5x5 with 8 entries.
0:   2.0000E+00   1.0000E+00                                       
1:   1.0000E+00   4.0000E+00   1.0000E+00                8.0000E+00
2:                1.0000E+00   3.0000E+00   2.0000E+00             
3:                             2.0000E+00                          
4:                8.0000E+00                             2.0000E+00
Matching:          0          4          3          2          1
Scaling:    7.07e-01   1.62e-01   2.78e-01   1.80e+00   7.72e-01
Scaled matrix:
Real symmetric indefinite matrix, dimension 5x5 with 8 entries.
0:   1.0000E+00   1.1443E-01                                       
1:   1.1443E-01   1.0476E-01   4.5008E-02                1.0000E+00
2:                4.5008E-02   2.3204E-01   1.0000E+00             
3:                             1.0000E+00                          
4:                1.0000E+00                             1.1932E+00
\end{verbatim}


\subsection{spral\_scaling\_equilib\_sym()}
The following example code:
\verbatiminput{examples/C/scaling/equilib_sym.c}
Produces the following output:
\begin{verbatim}
Initial matrix:
Real symmetric indefinite matrix, dimension 5x5 with 8 entries.
0:   2.0000E+00   1.0000E+00                                       
1:   1.0000E+00   4.0000E+00   1.0000E+00                8.0000E+00
2:                1.0000E+00   3.0000E+00   2.0000E+00             
3:                             2.0000E+00                          
4:                8.0000E+00                             2.0000E+00
Scaling:    7.07e-01   3.54e-01   5.77e-01   8.66e-01   3.54e-01
Scaled matrix:
Real symmetric indefinite matrix, dimension 5x5 with 8 entries.
0:   1.0000E+00   2.5000E-01                                       
1:   2.5000E-01   5.0000E-01   2.0412E-01                1.0000E+00
2:                2.0412E-01   1.0000E+00   9.9960E-01             
3:                             9.9960E-01                          
4:                1.0000E+00                             2.5000E-01
\end{verbatim}

\subsection{spral\_scaling\_hungarian\_sym()}
The following example code:
\verbatiminput{examples/C/scaling/hungarian_sym.c}
Produces the following output:
\begin{verbatim}
Initial matrix:
Real symmetric indefinite matrix, dimension 5x5 with 8 entries.
0:   2.0000E+00   1.0000E+00                                       
1:   1.0000E+00   4.0000E+00   1.0000E+00                8.0000E+00
2:                1.0000E+00   3.0000E+00   2.0000E+00             
3:                             2.0000E+00                          
4:                8.0000E+00                             2.0000E+00
Matching:          0          4          3          2          1
Scaling:    7.07e-01   3.54e-01   5.77e-01   8.66e-01   3.54e-01
Scaled matrix:
Real symmetric indefinite matrix, dimension 5x5 with 8 entries.
0:   1.0000E+00   2.5000E-01                                       
1:   2.5000E-01   5.0000E-01   2.0412E-01                1.0000E+00
2:                2.0412E-01   1.0000E+00   1.0000E+00             
3:                             1.0000E+00                          
4:                1.0000E+00                             2.5000E-01
\end{verbatim}
