\packagename{SCALING}
\version{1.0.0}
\versiondate{17 December 2014}
\purpose{
   This package generates various scalings (and matchings) of real sparse matrices.

   Given a \textbf{symmetric} matrix $A$, it finds a diagonal matrix $D$ such
   that the scaled matrix
   $$
      \hat{A} = DAD
   $$
   has specific numerical properties.

   Given an \textbf{unsymmetric} or \textbf{rectangular} matrix $A$, it finds
   diagonal matrices $D_r$ and $D_c$ such that the scaled matrix
   $$
      \hat{A} = D_r A D_c
   $$
   has specific numerical properties.

   The specific numerical properties delivered depends on the algorithm used:
   \begin{description}
      \item[Matching-based] algorithms scale $A$ such that the maximum
         (absolute) value in each row and column of $\hat{A}$ is exactly 1.0,
         where the entries of maximum value form a maximum cardinality matching.
         The \textbf{Hungarian algorithm} delivers an optimal matching slowly,
         whereas the \textbf{auction algorithm} delivers an approximate
         matching quickly.
      \item[Norm-equilibration] algorithms scale $A$ such that the infinity
         norm of each row and column of $\hat{A}$ is $1.0\pm \tau$ (for some
         user specified tolerance $\tau$).
   \end{description}
}

\title{Sparse Matrix Scalings}
\author{
   Jonathan Hogg (STFC Rutherford Appleton Laboratory) \\
}
\pkglang{C}
\spralmaketitle
\thispagestyle{firststyle}

\section*{Major version history}
\begin{description}
\item[2014-12-17 Version 1.0.0] Initial public release
\end{description}

%%%%%%%%%%%%%%%%%%%%%% installation %%%%%%%%%%%%%%%%%%%%%%

\section{Installation}
Please see the SPRAL install documentation.

%%%%%%%%%%%%%%%%%%%%%% how to use %%%%%%%%%%%%%%%%%%%%%%%%

\section{Usage overview}

\subsection{Calling sequences}

Access to the package requires inclusion of either \texttt{spral.h} (for the
entire \spral\ library) or \texttt{spral\_scaling.h} (for just the relevant routines). i.e.

\begin{verbatim}
   #include "spral.h"
\end{verbatim}

\newpage
\noindent
The following functions are available to the user:
\begin{itemize}
\item {\tt spral\_scaling\_default\_auction\_options()} initializes the options structure for the auction algorithm.
\item {\tt spral\_scaling\_default\_equilib\_options()} initializes the options structure for the norm equilibriation algorithm.
\item {\tt spral\_scaling\_default\_hungarian\_options()} initializes the options structure for the Hungarian algorithm.
\item {\tt spral\_scaling\_auction\_sym()} and \texttt{spral\_scaling\_auction\_unsym()} generate approximate matching-based scalings for symmetric and unsymmetric/rectangular matrices respectively using an auction algorithm.
\item {\tt spral\_scaling\_equilib\_sym()} and \texttt{spral\_scaling\_equilib\_unsym()} generate norm-equilibration scalings for symmetric and unsymmetric/rectangular matrices respectively.
\item {\tt spral\_scaling\_hungarian\_sym()} and \texttt{spral\_scaling\_hungarian\_unsym()} generate matching-based scalings for a symmetric and unsymmetric/rectangular matrices respectively using the Hungarian algorithm.
\end{itemize}

\subsection{Data formats} \label{dataformats}

\subsubsection{Compressed Sparse Column (CSC) Format} \label{cscformat}

\begin{figure}
   \caption{ \label{format eg}
      Data format example matrix (symmetric)
   }
   $$
      \left( \begin{array}{ccccc}
         1.1 & 2.2 &     & 3.3 &     \\
         2.2 &     & 4.4 &     &     \\
             & 4.4 & 5.5 &     & 6.6 \\
         3.3 &     &     & 7.7 & 8.8 \\
             &     & 6.6 & 8.8 & 9.9
      \end{array} \right)
   $$
\end{figure}

This standard data format consists of the following data:
\begin{verbatim}
   int    m;                  /* number of rows (unsymmetric matrix) */
   int    n;                  /* number of columns */
   int    ptr[ n+1 ];         /* column pointers (may have type long) */
   int    row[ ptr[n]-1 ];    /* row indices */
   double val[ ptr[n]-1 ];    /* numerical values */
\end{verbatim}
Non-zero matrix entries are ordered by increasing column index and stored in
the arrays \texttt{row[]} and \texttt{val[]} such that \texttt{row[k]} holds
the row number and \texttt{val[k]} holds the value of the \texttt{k}-th entry.
The \texttt{ptr[]} array stores column pointers such that \texttt{ptr[i]} is
the position in \texttt{row[]} and \texttt{val[]} of
the first entry in the \texttt{i}-th column, and \texttt{ptr[n]} is one more
than the total number of entries. \texttt{ptr[]} may alternatively have type
\texttt{long}, in which case the \texttt{\_long} variant of subroutine must
be used.
There must be no duplicate or out of range entries.
Entries that are zero, including those on the diagonal, need not be specified.

For \textbf{symmetric matrices}, only the lower triangular entries of $A$
should be supplied. For \textbf{unsymmetric matrices}, all entries in the matrix
should be supplied.

Note that these routines offer \textbf{no checking} of user data, and the
behaviour of these routines with misformatted data is undefined.

To illustrate the CSC format, the following arrays describe the symmetric
matrix shown in Figure~\ref{format eg}.
\begin{verbatim}
   int n = 5;
   int ptr[]    = { 0,             3,   4,        6,        8,    9 };
   int row[]    = { 0,   1,   3,   2,   2,   4,   3,   4,   4 };
   double val[] = { 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9 };
\end{verbatim}

%%%%%%%%%%%%%%%%%%%%%% argument lists %%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%% Auction %%%%%%

\section{Auction Algorithm}

\subsection{\texttt{spral\_scaling\_auction\_default\_options()}}

\textbf{To initialize a variable of type
   \texttt{struct spral\_scaling\_auction\_options} the following routine
   is provided.}

\vspace*{0.3cm}
\noindent
\textbf{\texttt{
   \hspace*{0.3cm} void spral\_scaling\_auction\_default\_options(struct spral\_scaling\_auction\_options *options);
}}
\vspace*{-0.4cm}

\begin{description}
   \item[\texttt{*options}] is the instance to be initialized.
\end{description}


\subsection{\texttt{spral\_scaling\_auction\_sym()}}

\textbf{\noindent
   To generate a scaling for a symmetric matrix using an auction algorithm such that the entry of maximum absolute value in each row and column is approximately 1.0,
}
\vspace*{-0.1cm}
\begin{verbatim}
   void spral_scaling_auction_sym(int n, const int *ptr, const int *row, const double *val,
      double *scaling, int *match, const struct spral_scaling_auction_options *options,
      struct spral_scaling_auction_inform *inform);
   void spral_scaling_auction_sym_long(int n, const long *ptr, const int *row, const double *val,
      double *scaling, int *match, const struct spral_scaling_auction_options *options,
      struct spral_scaling_auction_inform *inform);
\end{verbatim}

\begin{description}

\item[\texttt{n}, \texttt{ptr[n+1]}, \texttt{row[ptr[n]]}, \texttt{val[ptr[n]]}] must hold the lower triangular part of $A$ in compressed sparse column format as described in Section~\ref{dataformats}.

\item[\texttt{scaling[n]}] holds, on exit, the diagonal of $D$.
\texttt{scaling[i]} holds $d_i$, the scaling corresponding to the
\texttt{i}-th row and column.

\item[\texttt{match[m]}] may be \texttt{NULL}. If it is non-\texttt{NULL},
then on exit it specifies the matching of rows to columns.
Row \texttt{i} is matched to column \texttt{match[i]}, or is unmatched
if \texttt{match[i]}$=$\texttt{-1}.

\item[\texttt{*options}] specifies the algorithmic options used by the subroutine, as explained in Section~\ref{type:auction_options}.

\item[\texttt{*inform}] is used to return information about the execution of the subroutine, as explained in Section~\ref{type:auction_inform}.


\end{description}

\subsection{\texttt{spral\_scaling\_auction\_unsym()}}

\textbf{\noindent
   To generate a scaling for an unsymmetric or rectangular matrix using an auction algorithm such that the entry of maximum absolute value in each row and column is approximately 1.0,
}
\vspace*{-0.1cm}
\begin{verbatim}
   void spral_scaling_auction_unsym(int m, int n, const int *ptr, const int *row,
      const double *val, double *rscaling, double *cscaling, int *match,
      const struct spral_scaling_auction_options *options,
      struct spral_scaling_auction_inform *inform);
   void spral_scaling_auction_unsym_long(int m, int n, const long *ptr, const int *row,
      const double *val, double *rscaling, double *cscaling, int *match,
      const struct spral_scaling_auction_options *options,
      struct spral_scaling_auction_inform *inform);
\end{verbatim}

\begin{description}

\item[\texttt{m}, \texttt{n}, \texttt{ptr[n+1]}, \texttt{row[ptr[n]]}, \texttt{val[ptr[n]]}] must hold the lower triangular part of $A$ in compressed sparse column format as described in Section~\ref{dataformats}.

\item[\texttt{rscaling[m]}] holds, on exit, the diagonal of $D_r$.
\texttt{rscaling[i]} holds $d^r_i$, the scaling corresponding to
the \texttt{i}-th row.

\item[\texttt{cscaling[n]}] holds, on exit, the diagonal of $D_c$.
\texttt{cscaling[j]} holds $d^c_j$, the scaling corresponding to
the \texttt{j}-th column.

\item[\texttt{match[m]}] may be \texttt{NULL}. If it is non-\texttt{NULL},
then on exit it specifies the matching of rows to columns.
Row \texttt{i} is matched to column \texttt{match[i]}, or is unmatched
if \texttt{match[i]}$=$\texttt{-1}.

\item[\texttt{*options}] specifies the algorithmic options used by the subroutine, as explained in Section~\ref{type:auction_options}.

\item[\texttt{*inform}] is used to return information about the execution of the subroutine, as explained in Section~\ref{type:auction_inform}.


\end{description}

\subsection{\texttt{struct spral\_scaling\_auction\_options}} \label{type:auction_options}

The structure \texttt{spral\_scaling\_auction\_options} is used to specify the options
used by the routines \\\texttt{spral\_scaling\_auction\_sym()} and \texttt{spral\_scaling\_auction\_unsym()}. The components, that
must be given default values through a call to \texttt{spral\_scaling\_default\_auction\_options()}, are:

\begin{description}

\item[\texttt{int array\_base}] specifies the array indexing base. It must
   have the value either \texttt{0} (C indexing) or \texttt{1} (Fortran
   indexing). If \texttt{array\_base}$=$\texttt{1}, the entries of arrays
   \texttt{ptr[]},\texttt{row[]} and \texttt{match[]} start at 1, not 0.
   Further, entries of \texttt{match[]} that are unmatched are indicated by a
   value of \texttt{0}, not \texttt{-1}.
   The default value is \texttt{array\_base}$=$\texttt{0}.

\item[\texttt{float eps\_initial}] specifies the initial value of the minimum improvement parameter $\epsilon$ as described in Section~\ref{method:auction}.

\item[\texttt{int max\_iterations}] specifies the maximum number of iterations the algorithm may perform. The default is \texttt{max\_iterations}$=$\texttt{30000}.

\item[\texttt{int max\_unchanged[3]}] specifies, together with \texttt{min\_proportion[]}, the termination conditions for the algorithm, as described in Section~\ref{method:auction}. The default is \texttt{max\_unchanged[]} $=$ \texttt{\{ 10, 100, 100 \}}.

\item[\texttt{float min\_proportion[3]}] specifies, together with \texttt{max\_unchanged(:)}, the termination conditions for the algorithm, as described in Section~\ref{method:auction}. The default is \texttt{min\_proportion[]} $=$ \texttt{\{ 0.90, 0.0, 0.0 \}}.

\end{description}

\subsection{\texttt{struct spral\_scaling\_auction\_inform}} \label{type:auction_inform}

The structure \texttt{spral\_scaling\_auction\_inform} is used to hold parameters that
give information about the progress of the routines
\texttt{spral\_scaling\_auction\_sym()} and \texttt{spral\_scaling\_auction\_unsym()}. The components are:

\begin{description}

\item[\texttt{int flag}] gives the exit status of the algorithm (details in Section~\ref{returns:auction}).

\item[\texttt{int iterations}] holds the number of iterations performed.

\item[\texttt{int matched}] holds the number of rows and columns that have been matched. As the algorithm may terminate before a full matching is obtained, this only provides a lower bound on the structural rank.

\item[\texttt{int stat}] holds, in the event of an allocation error, the Fortran \texttt{stat} parameter if it is available (and is set to \texttt{0} otherwise).

\item[\texttt{int unmatchable}] holds the number of columns designated as unmatchable. A column is designated as unmatchable if there is no way to match it that improves the quality of the matching. It provides an approximate lower bound on the structural rank deficiency.

\end{description}

\subsection{Error Flags} \label{returns:auction}
A successful return from a routine is indicated by \texttt{inform.flag} having the value zero. A negative value is associated with an error message.

Possible negative (error) values are:
\begin{description}
\item[\texttt{-1}] Allocation error. If available, the Fortran \texttt{stat} parameter is returned in \texttt{inform.stat}.
\end{description}

\subsection{Algorithm description} \label{method:auction}

This algorithm finds a fast approximation to the matching and scaling produced
by the HSL package \texttt{MC64}. If an optimal matching is required, use the
Hungarian algorithm instead. The algorithm works by solving the following
maximum product optimization problem using an auction algorithm. The scaling
is derived from the dual variables associated with the solution.
\begin{eqnarray*}
   \max_{\sigma} & \prod_{i=1}^m\prod_{j=1}^n |a_{ij}|\sigma_{ij} & \\
   \mathrm{s.t.} & \sum_{i=1}^m\sigma_{ij} = 1, & \forall j=1,n \\
                 & \sum_{j=1}^n\sigma_{ij} = 1, & \forall i=1,m \\
                 & \sigma_{ij} \in \{0,1\}.
\end{eqnarray*}
The array $\sigma$ gives a matching of rows to columns.

By using the transformation
$$
   w_{ij} = \log c_j - \log |a_{ij}|,
$$
where $c_j = \max_i |a_{ij}|$, the maximum product problem in $a_{ij}$ is
replaced by a minimum sum problem in $w_{ij}$ where all entries are positive.
By standard optimization theory, there exist dual variables $u$ and $v$
corresponding to the constraints that satisfy the first order optimality
conditions
\begin{eqnarray*}
   w_{ij} - u_i - v_j = 0, && \mbox{if } \sigma_{ij }=1, \\
   w_{ij} - u_i - v_j \ge 0, && \mbox{if } \sigma_{ij }=0.
\end{eqnarray*}
To obtain a scaling we define scaling matrices $D_r$ and $D_c$ as
\begin{eqnarray*}
   & d^r_i = e^{u_i}, & \\
   & d^c_i = e^{v_i}. &
\end{eqnarray*}
If a symmetric scaling is required, we average these as
$$
   d_i = \sqrt{d^r_id^c_i}.
$$
By the first order optimality conditions, these scaling matrices guarantee that
\begin{eqnarray*}
   d^r_i|a_{ij}|d^c_j = 1, && \mbox{if } \sigma_{ij}=1, \\
   d^r_i|a_{ij}|d^c_j \le 1, && \mbox{if } \sigma_{ij}=0.
\end{eqnarray*}

To solve the minimum sum problem an auction algorithm is used. The 
algorithm is \textit{not} guaranteed to find an optimal matching. However it
can find an approximate matching very quickly. A matching is maintained along
with the row pricing vector $u$.
In each major iteration, we loop over each column in turn. If the
column $j$ is unmatched, we calculate the value $p_i = w_{ij} - u_i$ for each
entry and find the maximum across the column. If this maximum is positive, the
current matching can be improved by matching column $j$ with row $i$. This may
mean that the previous match of row $i$ now becomes unmatched. We update the
price of row $i$, that is $u_i$, to reflect this new benefit and continue to the
next column.

To prevent incremental shuffling, we insist that the value of
adding a new column is at least a threshold value $\epsilon$ above zero, where
$\epsilon$ is based on the last iteration in which row $i$ changed its match.
This is done by adding $\epsilon$ to the price $u_i$, where $\epsilon = \texttt{options.eps\_initial} + \texttt{itr} / (n+1)$, where \texttt{itr} is the current iteration number.

The algorithm terminates if any of the following are satisfied:
\begin{itemize}
   \item All entries are matched.
   \item The number of major iterations exceeds \texttt{options.max\_iterations}.
   \item At least \texttt{options.max\_unchanged[0]} iterations have passed without the cardinality of the matching increasing, and the proportion of matched columns is \texttt{options.min\_proportion[0]}.
   \item At least \texttt{options.max\_unchanged[1]} iterations have passed without the cardinality of the matching increasing, and the proportion of matched columns is \texttt{options.min\_proportion[1]}.
   \item At least \texttt{options.max\_unchanged[2]} iterations have passed without the cardinality of the matching increasing, and the proportion of matched columns is \texttt{options.min\_proportion[2]}.
\end{itemize}

The different combinations given by \texttt{options.max\_unchanged[0:2]}
and
\texttt{options.min\_proportion[0:2]} allow a wide range of termination
heuristics to be specified by the user depending on their particular needs. Note
that the matching and scaling produced will always be approximate as
$\epsilon$ is non-zero.

\vspace{0.2cm}
\noindent
Further details are given in the following paper:
\vspace{-0.2cm}
\begin{itemize}
   \item[{[1]}] J.D. Hogg and J.A. Scott. (2014). On the efficient scaling of sparse symmetric matrices using an auction algorithm. RAL Technical Report RAL-P-2014-002.
\end{itemize}

\subsection{Example of spral\_scaling\_auction\_sym()}
The following code shows an example usage of \texttt{spral\_scaling\_auction\_sym()}.
\verbatiminput{examples/C/scaling/auction_sym.c}
\newpage
The above code produces the following output.
\begin{verbatim}
Initial matrix:
Real symmetric indefinite matrix, dimension 5x5 with 8 entries.
0:   2.0000E+00   1.0000E+00                                       
1:   1.0000E+00   4.0000E+00   1.0000E+00                8.0000E+00
2:                1.0000E+00   3.0000E+00   2.0000E+00             
3:                             2.0000E+00                          
4:                8.0000E+00                             2.0000E+00
Matching:          0          4          3          2          1
Scaling:    7.07e-01   1.62e-01   2.78e-01   1.80e+00   7.72e-01
Scaled matrix:
Real symmetric indefinite matrix, dimension 5x5 with 8 entries.
0:   1.0000E+00   1.1443E-01                                       
1:   1.1443E-01   1.0476E-01   4.5008E-02                1.0000E+00
2:                4.5008E-02   2.3204E-01   1.0000E+00             
3:                             1.0000E+00                          
4:                1.0000E+00                             1.1932E+00
\end{verbatim}

%%%%%%%%% Equilibration %%%%%%

\section{Norm-equilibration algorithm}

\subsection{spral\_scaling\_equilib\_default\_options()}

\textbf{To initialize a variable of type
   \texttt{struct spral\_scaling\_equilib\_options} the following routine
   is provided.}

\vspace*{0.3cm}
\noindent
\textbf{\texttt{
   \hspace*{0.3cm} void spral\_scaling\_equilib\_default\_options(struct spral\_scaling\_equilib\_options *options);
}}
\vspace*{-0.4cm}

\begin{description}
   \item[\texttt{*options}] is the instance to be initialized.
\end{description}

\subsection{\texttt{spral\_scaling\_equilib\_sym()}}

\textbf{\noindent
   To generate a scaling for a symmetric matrix using a norm equilibration algorithm such that the infinity norm of each row and column is equal to $1.0\pm\tau$,
}
\vspace*{-0.1cm}
\begin{verbatim}
   void spral_scaling_equilib_sym(int n, const int *ptr, const int *row, const double *val,
      double *scaling, const struct spral_scaling_equilib_options *options,
      struct spral_scaling_equilib_inform *inform);
   void spral_scaling_equilib_sym_long(int n, const long *ptr, const int *row, const double *val,
      double *scaling, const struct spral_scaling_equilib_options *options,
      struct spral_scaling_equilib_inform *inform);
\end{verbatim}

\begin{description}

\item[\texttt{n}, \texttt{ptr[n+1]}, \texttt{row[ptr[n]]}, \texttt{val[ptr[n]]}] must hold the lower triangular part of $A$ in compressed sparse column format as described in Section~\ref{dataformats}.

\item[\texttt{scaling[n]}] holds, on exit, the diagonal of $D$.
\texttt{scaling[i]} holds $d_i$, the scaling corresponding to the
\texttt{i}-th row and column.

\item[\texttt{*options}] specifies the algorithmic options used by the subroutine, as explained in Section~\ref{type:equilib_options}.

\item[\texttt{*inform}] is used to return information about the execution of the subroutine, as explained in Section~\ref{type:equilib_inform}.


\end{description}


\subsection{\texttt{spral\_scaling\_equilib\_unsym()}}

\textbf{\noindent
   To generate a scaling for an unsymmetric or rectangular matrix using a norm equilibration algorithm such that the infinity norm of each row and column is equal to $1.0\pm\tau$,
}
\vspace*{-0.1cm}
\begin{verbatim}
   void spral_scaling_equilib_unsym(int m, int n, const int *ptr, const int *row,
      const double *val, double *rscaling, double *cscaling,
      const struct spral_scaling_equilib_options *options,
      struct spral_scaling_equilib_inform *inform);
   void spral_scaling_equilib_unsym_long(int m, int n, const long *ptr, const int *row,
      const double *val, double *rscaling, double *cscaling,
      const struct spral_scaling_equilib_options *options,
      struct spral_scaling_equilib_inform *inform);
\end{verbatim}

\begin{description}

\item[\texttt{m}, \texttt{n}, \texttt{ptr[n+1]}, \texttt{row[ptr[n]]}, \texttt{val[ptr[n]]}] must hold the lower triangular part of $A$ in compressed sparse column format as described in Section~\ref{dataformats}.

\item[\texttt{rscaling[m]}] holds, on exit, the diagonal of $D_r$.
\texttt{scaling[i]} holds $d_i^r$, the scaling corresponding to the
\texttt{i}-th row.

\item[\texttt{cscaling[n]}] holds, on exit, the diagonal of $D_c$.
\texttt{scaling[j]} holds $d_j^c$, the scaling corresponding to the
\texttt{j}-th column.

\item[\texttt{*options}] specifies the algorithmic options used by the subroutine, as explained in Section~\ref{type:equilib_options}.

\item[\texttt{*inform}] is used to return information about the execution of the subroutine, as explained in Section~\ref{type:equilib_inform}.


\end{description}

\subsection{\texttt{struct spral\_scaling\_equilib\_options}} \label{type:equilib_options}

The structure \texttt{spral\_scaling\_equilib\_options} is used to specify the options
used by the routines \\\texttt{spral\_scaling\_equilib\_sym()} and \texttt{spral\_scaling\_equilib\_unsym()}. The components, that
must be given default values through a call to \texttt{spral\_scaling\_default\_equilib\_options()}, are:

\begin{description}

\item[\texttt{int array\_base}] specifies the array indexing base. It must
   have the value either \texttt{0} (C indexing) or \texttt{1} (Fortran
   indexing). If \texttt{array\_base}$=$\texttt{1}, the entries of arrays
   \texttt{ptr[]} and \texttt{row[]} start at 1, not 0.
   The default value is \texttt{array\_base}$=$\texttt{0}.

\item[\texttt{int max\_iterations}] specifies the maximum number of iterations the algorithm may perform. The default is \texttt{max\_iterations}=\texttt{10}.

\item[\texttt{float tol}] specifies the convergence tolerance for the algorithm (though often termination is based on \texttt{max\_iterations}). The default is \texttt{tol} = \texttt{1e-8}.

\end{description}

\subsection{\texttt{struct spral\_scaling\_equilib\_inform}} \label{type:equilib_inform}

The structure \texttt{spral\_scaling\_equilib\_inform} is used to hold parameters that
give information about the progress of the routines
\texttt{spral\_scaling\_equilib\_sym()} and \texttt{spral\_scaling\_equilib\_unsym()}. The components are:

\begin{description}

\item[\texttt{int flag}] gives the exit status of the algorithm (details in Section~\ref{returns:equilib}).

\item[\texttt{int iterations}]  holds, on exit,
   the number of iterations performed.

\item[\texttt{int stat}] holds, in the event of an allocation error or deallocation error, the Fortran \texttt{stat} parameter if it is available (and is set to \texttt{0} otherwise).

\end{description}

\subsection{Error Flags} \label{returns:equilib}
A successful return from a routine is indicated by \texttt{inform.flag} having the value zero. A negative value is associated with an error message.

Possible negative (error) values are:
\begin{description}
\item[\texttt{-1}] Allocation error. If available, the Fortran \texttt{stat} parameter is returned in \texttt{inform.stat}.
\end{description}

\subsection{Algorithm description}

This algorithm is very similar to that used by the HSL routine \texttt{MC77}.
An iterative method
is used to scale the infinity norm of both rows and columns to 1 with an asymptotic linear rate of convergence of $\frac{1}{2}$, preserving symmetry if the matrix is symmetric.

\noindent
For unsymmetric matrices, the algorithm outline is as follows:
\begin{algorithmic}
   \setlength{\itemsep}{2pt}
   \STATE $D_r^{(0)} = I, D_c^{(0)}=I$
   \FOR{$k=1, \texttt{options.max\_iterations}$}
      \setlength{\itemsep}{2pt}
      \STATE $A^{(k-1)} = D_r^{(k-1)} A D_c^{(k-1)}$
      \STATE $(D_r^{(k)})_{ii} = (D_r^{(k-1)})_{ii}\; /\; \sqrt{\max_j(A^{(k-1)})_{ij}}$
      \STATE $(D_c^{(k)})_{jj} = (D_c^{(k-1)})_{jj}\; /\; \sqrt{\max_i(A^{(k-1)})_{ij}}$
      \STATE\textbf{if}($|1-\|A^{(k-1)}\|_{\max}|\le\texttt{options.tol}$) \textbf{exit}
   \ENDFOR
\end{algorithmic}
For symmetric matrices, $A^{(k-1)}$ is symmetric, so $D_r^{(k)} = D_c^{(k)}$, and
some operations can be skipped.

\vspace*{0.3cm}
\noindent
Further details are given in the following paper:
\vspace{-0.1cm}
\begin{itemize}
   \item[{[2]}] P. Knight, D. Ruiz and B. Ucar. (2012). A symmetry preserving algorithm for matrix scaling. INRIA Research Report 7552.
\end{itemize}

\subsection{Example of spral\_scaling\_equilib\_sym()}
The following code shows an example usage of \texttt{spral\_scaling\_equilib\_sym()}.
\verbatiminput{examples/C/scaling/equilib_sym.c}
The above code produces the following output.
\begin{verbatim}
Initial matrix:
Real symmetric indefinite matrix, dimension 5x5 with 8 entries.
0:   2.0000E+00   1.0000E+00                                       
1:   1.0000E+00   4.0000E+00   1.0000E+00                8.0000E+00
2:                1.0000E+00   3.0000E+00   2.0000E+00             
3:                             2.0000E+00                          
4:                8.0000E+00                             2.0000E+00
Scaling:    7.07e-01   3.54e-01   5.77e-01   8.66e-01   3.54e-01
Scaled matrix:
Real symmetric indefinite matrix, dimension 5x5 with 8 entries.
0:   1.0000E+00   2.5000E-01                                       
1:   2.5000E-01   5.0000E-01   2.0412E-01                1.0000E+00
2:                2.0412E-01   1.0000E+00   9.9960E-01             
3:                             9.9960E-01                          
4:                1.0000E+00                             2.5000E-01
\end{verbatim}

%%%%%%%%% Hungarian %%%%%%

\section{Hungarian algorithm}

\subsection{\texttt{spral\_scaling\_hungarian\_default\_options()}}

\textbf{To initialize a variable of type
   \texttt{struct spral\_scaling\_hungarian\_options} the following routine
   is provided.}

\vspace*{0.3cm}
\noindent
\textbf{\texttt{
   \hspace*{0.3cm} void spral\_scaling\_hungarian\_default\_options(struct spral\_scaling\_hungarian\_options *options);
}}
\vspace*{-0.4cm}

\begin{description}
   \item[\texttt{*options}] is the instance to be initialized.
\end{description}

\subsection{\texttt{spral\_scaling\_hungarian\_sym()}}

\textbf{\noindent
   To generate a scaling for a symmetric matrix using the Hungarian algorithm such that the entry of maximum absolute value in each row and column is 1.0,
}
\vspace*{-0.1cm}
\begin{verbatim}
   void spral_scaling_hungarian_sym(int n, const int *ptr, const int *row, const double *val,
      double *scaling, int *match, const struct spral_scaling_hungarian_options *options,
      struct spral_scaling_hungarian_inform *inform);
   void spral_scaling_hungarian_sym_long(int n, const long *ptr, const int *row, const double *val,
      double *scaling, int *match, const struct spral_scaling_hungarian_options *options,
      struct spral_scaling_hungarian_inform *inform);
\end{verbatim}

\begin{description}

\item[\texttt{n}, \texttt{ptr[n+1]}, \texttt{row[ptr[n]]}, \texttt{val[ptr[n]]}] must hold the lower triangular part of $A$ in compressed sparse column format as described in Section~\ref{dataformats}.

\item[\texttt{scaling[n]}] holds, on exit, the diagonal of $D$.
\texttt{scaling[i]} holds $D_{ii}$, the scaling corresponding to the
\texttt{i}-th row and column.

\item[\texttt{match[m]}] may be \texttt{NULL}. If it is non-\texttt{NULL},
then on exit it specifies the matching of rows to columns.
Row \texttt{i} is matched to column \texttt{match[i]}, or is unmatched
if \texttt{match[i]}$=$\texttt{-1}.

\item[\texttt{*options}] specifies the algorithmic options used by the subroutine, as explained in Section~\ref{type:hungarian_options}.

\item[\texttt{*inform}] is used to return information about the execution of the subroutine, as explained in Section~\ref{type:hungarian_inform}.


\end{description}

\subsection{\texttt{spral\_scaling\_hungarian\_unsym()}}

\textbf{\noindent
   To generate a scaling for an unsymmetric or rectangular matrix using the Hungarian algorithm such that the entry of maximum absolute value in each row and column is 1.0,
}
\vspace*{-0.1cm}
\begin{verbatim}
   void spral_scaling_hungarian_unsym(int m, int n, const int *ptr, const int *row,
      const double *val, double *rscaling, double *cscaling, int *match,
      const struct spral_scaling_hungarian_options *options,
      struct spral_scaling_hungarian_inform *inform);
   void spral_scaling_hungarian_unsym_long(int m, int n, const long *ptr, const int *row,
      const double *val, double *rscaling, double *cscaling, int *match,
      const struct spral_scaling_hungarian_options *options,
      struct spral_scaling_hungarian_inform *inform);
\end{verbatim}

\begin{description}

\item[\texttt{m}, \texttt{n}, \texttt{ptr[n+1]}, \texttt{row[ptr[n]]}, \texttt{val[ptr[n]]}] must hold the lower triangular part of $A$ in compressed sparse column format as described in Section~\ref{dataformats}.

\item[\texttt{rscaling[m]}] holds, on exit, the diagonal of $D_r$.
\texttt{rscaling[i]} holds $d^r_i$, the scaling corresponding to the
\texttt{i}-th row.

\item[\texttt{cscaling[n]}] holds, on exit, the diagonal of $D_c$.
\texttt{cscaling[j]} holds $d^c_j$, the scaling corresponding to the
\texttt{j}-th column.

\item[\texttt{match[m]}] may be \texttt{NULL}. If it is non-\texttt{NULL},
then on exit it specifies the matching of rows to columns.
Row \texttt{i} is matched to column \texttt{match[i]}, or is unmatched
if \texttt{match[i]}$=$\texttt{-1}.

\item[\texttt{*options}] specifies the algorithmic options used by the subroutine, as explained in Section~\ref{type:hungarian_options}.

\item[\texttt{*inform}] is used to return information about the execution of the subroutine, as explained in Section~\ref{type:hungarian_inform}.


\end{description}

\subsection{\texttt{struct spral\_scaling\_hungarian\_options}} \label{type:hungarian_options}

The structure \texttt{spral\_scaling\_hungarian\_options} is used to specify the
options used by the routines \\\texttt{spral\_scaling\_hungarian\_sym()} and \texttt{spral\_scaling\_hungarian\_unsym()}. The components,
that must be given default values through a call to \texttt{spral\_scaling\_default\_hungarian\_options()}, are:

\begin{description}

\item[\texttt{int array\_base}] specifies the array indexing base. It must
   have the value either \texttt{0} (C indexing) or \texttt{1} (Fortran
   indexing). If \texttt{array\_base}$=$\texttt{1}, the entries of arrays
   \texttt{ptr[]},\texttt{row[]} and \texttt{match[]} start at 1, not 0.
   Further, entries of \texttt{match[]} that are unmatched are indicated by a
   value of \texttt{0}, not \texttt{-1}.
   The default value is \texttt{array\_base}$=$\texttt{0}.

\item[\texttt{bool scale\_if\_singular}]
specifies whether scaling shuold continue if the matrix $A$ is found to be
structurally singular. If \texttt{scale\_if\_singular}$=$\texttt{true},
and the $A$ is structurally singular, a partial scaling corresponding to a
maximum cardinality matching will be returned and a warning issued. Otherwise
an identity scaling will be returned and an error issued.

\end{description}

\subsection{\texttt{struct spral\_scaling\_hungarian\_inform}} \label{type:hungarian_inform}

The structure \texttt{spral\_scaling\_hungarian\_inform} is used to hold parameters
that give information about the progress of the routines
\texttt{spral\_scaling\_hungarian\_sym()} and \texttt{spral\_scaling\_hungarian\_unsym()}. The components are:

\begin{description}

\item[\texttt{int flag}] gives the exit status of the algorithm (details in Section~\ref{returns:hungarian}).

\item[\texttt{int matched}] holds the number of rows and columns that have been matched (i.e.~the structural rank).

\item[\texttt{int stat}] holds, in the event of an allocation error or deallocation error, the Fortran \texttt{stat} parameter if it is available (and is set to \texttt{0} otherwise).
\end{description}

%%%%%%%%%%%%%% ERROR FLAGS %%%%%%%%%%%%%%%%%%%%%%

\subsection{Error Flags} \label{returns:hungarian}
A successful return from a routine is indicated by \texttt{inform.flag} having the value zero. A negative value is associated with an error message and a positive value with a warning.

Possible negative (error) values are:
\begin{description}
\item[\texttt{-1}] Allocation error. If available, the Fortran \texttt{stat} parameter is returned in \texttt{inform.stat}.
\item[\texttt{-2}] Matrix $A$ is structurally rank-deficient. This error is
   returned only if
   \texttt{options.scale\_if\_singular}$=$\texttt{false}. The scaling vector
   is set to \texttt{1.0} and a matching of maximum cardinality returned
   in the optional argument \texttt{match[]}, if present.
\end{description}

Possible positive (warning) values are:
\begin{description}
\item[\texttt{+1}] Matrix $A$ is structurally rank-deficient. This warning is
   returned only if
   \texttt{options.scale\_if\_singular}$=$\texttt{true}.
\end{description}

\subsection{Algorithm description}

This algorithm is the same as used by the HSL package \texttt{MC64}. A scaling
is derived from dual variables found during the solution of the below
maximum product optimization problem using the Hungarian algorithm.
\begin{eqnarray*}
   \max_{\sigma} & \prod_{i=1}^m\prod_{j=1}^n |a_{ij}|\sigma_{ij} & \\
   \mathrm{s.t.} & \sum_{i=1}^m\sigma_{ij} = 1, & \forall j=1,n \\
                 & \sum_{j=1}^n\sigma_{ij} = 1, & \forall i=1,m \\
                 & \sigma_{ij} \in \{0,1\}.
\end{eqnarray*}
The array $\sigma$ gives a matching of rows to columns.

By using the transformation
$$
   w_{ij} = \log c_j - \log |a_{ij}|,
$$
where $c_j = \max_i |a_{ij}|$, the maximum product problem in $a_{ij}$ is
replaced by a minimum sum problem in $w_{ij}$ where all entries are positive.
By standard optimization theory, there exist dual variables $u$ and $v$
corresponding to the constraints that satisfy the first order optimality
conditions
\begin{eqnarray*}
   w_{ij} - u_i - v_j = 0, && \mbox{if } \sigma_{ij }=1, \\
   w_{ij} - u_i - v_j \ge 0, && \mbox{if } \sigma_{ij }=0.
\end{eqnarray*}
To obtain a scaling we define scaling matrices $D_r$ and $D_c$ as
\begin{eqnarray*}
   & d^r_i = e^{u_i}, & \\
   & d^c_i = e^{v_i}. &
\end{eqnarray*}
If a symmetric scaling is required, we average these as
$$
   d_i = \sqrt{d^r_id^c_i}.
$$
By the first order optimality conditions, these scaling matrices guarantee that
\begin{eqnarray*}
   d^r_i|a_{ij}|d^c_j = 1, && \mbox{if } \sigma_{ij}=1, \\
   d^r_i|a_{ij}|d^c_j \le 1, && \mbox{if } \sigma_{ij}=0.
\end{eqnarray*}

To solve the minimum sum problem, the Hungarian algorithm maintains an optimal
matching on a subset of
the rows and columns. It proceeds to grow this set by finding augmenting paths
from an unmatched row to an unmatched column. The algorithm is guaranteed to
find the optimal solution in a fixed number of steps, but can be very slow as
it may need to explore the full matrix a number of times equal to the dimension
of the matrix. To minimize the solution time, a warmstarting heuristic is used
to construct an initial optimal subset matching.

\noindent
Further details are given in the following paper:
\begin{itemize}
   \item[{[3]}] I.S. Duff and J. Koster. (1997). The design and use of algorithms for permuting large entries to the diagonal of sparse matrices. SIAM J. Matrix Anal. Applics. 20(4), pp 889--901.
\end{itemize}

\subsection{Example usage of spral\_scaling\_hungarian\_unsym()}
The following code shows an example usage of \texttt{hungarian\_scale\_unsym()}.
\verbatiminput{examples/C/scaling/hungarian_unsym.c}
The above code produces the following output.
\begin{verbatim}
Initial matrix:
Real unsymmetric matrix, dimension 5x5 with * entries.
0:   2.0000E+00   5.0000E+00                                       
1:   1.0000E+00   4.0000E+00                             7.0000E+00
2:                1.0000E+00                2.0000E+00             
3:                             3.0000E+00                          
4:                8.0000E+00                             2.0000E+00
Matching:          0          4          3          2          1
Row Scaling:    5.22e-01   5.22e-01   5.22e-01   5.22e-01   5.22e-01
Col Scaling:    9.59e-01   2.40e-01   6.39e-01   9.59e-01   2.74e-01
Scaled matrix:
Real unsymmetric matrix, dimension 5x5 with * entries.
0:   1.0000E+00   6.2500E-01                                       
1:   5.0000E-01   5.0000E-01                             1.0000E+00
2:                1.2500E-01                1.0000E+00             
3:                             1.0000E+00                          
4:                1.0000E+00                             2.8571E-01
\end{verbatim}
